pip intall django

python -m django --version

Los proyectos de Django se dividen en tres partes (MVT) :

Model --> Bases de datos

View -->  Funciones Python

Templates --> Plantillas HTML


##########################################  CREAR UN PROYECTO  ####################################################################

- Creamos la carpeta de proyectos para Django en nuestro IDE,  luego dentro de esta hay que crear una carpeta de proyecto en la consola
de este modo:

django-admin startproject nombre_proyecto
im
Esto crea la carpeta nombre_proyecto y colgando de ella una subcarpeta de archivos de proyecto con el mismo nombre y el archivo manage.py
que contiene los comandos de Django

Dentro de la subcarpeta hay varios archivos importantes, entre ellos:

settings --> Contiene las configuraciones del proyecto, aqui está la lista de INSTALLED_APPS con las app
	     que vienen de serie, y en la cual debemos incluir las apps que vayamos creando para el proyecto

urls.py --> Contiene las rutas

Dentro de la carpeta de proyecto , en la linea de comandos ejecutamos esto:

python manage.py migrate

Esto crea el archivo db.sqlite3 para la base de datos (luego se pueden modificar configuraciones para conectar con otras)

-Comprobamos que el proyecto arranca usando el servidor interno de django (servidor sólo util para comprobaciones, no para producción):

python manage.py runserver

La URL que nos da la podemos cargar en el navegador para ver que el proyecto está arrancado

- El proyecto estará dividido en varias apps,  para crear una app:

python manage.py startapp nombre_app

Esto crea otra subcarpeta con el nombre de la app, y dentro a su vez se creará otra subcarpeta llamada migrations y varios archivos:

models.py --> Contiene las clases para crear las tablas en la BBDD

views.py --> Contiene las funciones Python asociadas a las rutas web

apps.py  --> Contiene la clase de nuestra nueva app

-Una vez creada la mueva app,  hay que incluirla en la lista INSTALLED_APPS del archivo settings.py de la subcarpeta principal nombre_proyecto.
Para hacerlo, necesitamos saber el nombre de clase que se ha creado para nuestra app en el archivo apps.py de la subcarpeta nombre_app

Ej.

INSTALLED_APPS = [
    'nombre_app.apps.nombre_clase',
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
]

La recepción y envio de información en el VIEW se hace con objetos de las clases Request (recepción) y HttpResponse (envío)

Dentro del archvio views.py hacemos esta importación:

from django.http import HttpResponse

En este archivo se contienen lo que Django llama "vistas" , que son funciones Python , estas funciones deben recibir siempre como 
parametro el objeto request , y luego pueden recibir parametros adicionales

Ej.  def inicio(request , posible_parametro_adicional):
         return HttpResponse("Hola Mundo")

Para cada "vista" que creemos que en el views.py , debemos asignarle una ruta en el archivo urls.py

Es buena práctica crear un urls.py para cada proyecto y luego llamarlo desde el urls.py de la subcarpeta principal del proyecto
de esta manera:

Ej.  

from django.urls.conf import include

urlpatterns = [
    path('nombre_app/',include("nombre_app.urls")),
    path('admin/', admin.site.urls),
]

Y luego en el urls.py que hayamos creado en la carpeta nombre_app:

from . import views
from django.urls import path

urlpatterns = [
    path("nombre_ruta/", views.nombre_funcion_asociada_a_la_ruta)
    ]

Si la ruta la dejamos vacia con "" , definimos una raiz a partir de la ruta "padre/" que hayamos definido en el archivo urls.py de la
carpeta principal nombre_proyecto

El archvio urls.py contiene una lista con las rutas de nuestro proyecto, ahi debemos incluir las rutas para las vistas que
vayamos creando (haciendo la pertinente importación) el formato de la ruta será este:

from nombre_app.views import nombre_vista

path("nombre_ruta/" , nombre_vista)

En las rutas se pueden incluir parámetros mediante la notación <parámetro> ,  por defecto lo que se indique será string, si por
ejemplo queremos pasar un número, la notaación será "nombre_ruta/<int:parámetro>" .  Los parámetros que pasemos por URL deben
ser recogidos por la vista

Ej.  path("ruta1/<parametro_string>/<int:parametro_numerico>/" , funcion_vista)

     def funcion_vista(request, parametro_string, parametro_numerico):
         código.............


#####################################  TEMPLATES  ###############################################################3

Dentro de la subcarpeta del proyecto, creamos la subcarpeta templates e incluinos en ella todas las plantillas HTML

Para renderizar las plantillas, en las vistas de view.py devolvemos lo siguiente :

return render(request, "nombre_plantilla.html")

Si además traemos datos desde una BBDD hay que añadir la variable context ( contenido dinámico) :

return render(request, "nombre_plantilla.html", context)

La vaiable context contiene un diccionario donde indicamos como clave el nombre de la variable que mostramos en los {{ }} del HTML
y como valor lo que contenga dicha variable.  Recordar que como valor también se pueden pasar objetos iterables

Ej.  Traemos un listado de anuncios desde la BBDD

def inicio(request):
    resultado = models.Anuncio.objects.order_by("-id")
    context = { "anuncios" : resultado }
    return render(request, "index.html", context)

En las anotaciones {{ }} podemos incluso trear propiedades de objetos ( {{ objeto.propiedad }} ) y también sus métodos ( {{ objeto.metodo }} )
que en este caso no deben cerrarse con ()

Para usar bucles y condicionales,  hay que usar la notación {%  %} .....  {%end...%}

Dentro de estas anotaciones Jinja se pueden aplicar filtros usando el símbolo pipe | 

Ej.  nombre = Juan

     {{ nombre|first|lower }}  -->  j 


También podemos incrustar plantillas HTML dentro de otra plantilla 

{% include "sub_plantilla.html" %}

Y podemos usar HERENCIA DE PLANTILLAS creando un plantilla Padre e invocandola en las hijas mediante

{% extends "plantilla_padre.html" %}

En la plantilla Padre hay que definiar los bloques cambiantes:

Para el título --> <title> {% block title %}  {% endblock %} </title>

Para el contenido  --> <body> {% block content %}  {% endblock %}

Y estos mismos bloques son invocados en las plantillas hijas dentrás de {% extends "plantilla_padre.html" %} para personalizar su contenido
HTML individual , donde podremos incluso incrustar otras plantillas con {% include "sub_plantilla.html" %}


CARGADOR DE PLANTILLAS

from django.template import loader

En el archivo settings.py hay un diccionario dentro de TEMPLATES que contiene "DIRS : []" , ahi podemos incluir la ruta hacia la carpeta
que contiene nuestras plantillas , ej "DIRS : ["./templates"] , tras esto en la vista podemos almacenar la plantilla en una variable de
esta manera :

doc_plantilla = loader.get_template("nombre_plantilla.html")

Y tras definir el diccionario contenido en el context,  la podemos renderizar de esta manera:

documento = doc_plantilla.render(context)
return HttpResponse(documento)

Pero tenemos también la opción más rápida de usar el módulo render de las shortcuts functions de Django:

from django.shorcuts import render

return render(request, "nombre_plantilla_html", context) --> Este método requiere que exista una carpeteta templates en la 
							     subcarpeta del proyecto

PARAMETROS EN URL

A parte de las conocidas anotaciones ? y & ,  Django permite pasar variables "url friendly" a través de las URL de las rutas suando 
la anotación <variable>. Por defecto,  esta variable contiene un string, si es necesario un número entero habria que indicar <int:variable> 
y si es un número real sería <float:variable>

La vista que deba procesar la variable , deberá recibirla como argumento , y en la llamada a la ruta en el HTML por ejemplo en un botón,
podemos sustituir su valor por un contenido entre {{}}:

Ej

path("borrar-anuncio/<id_anuncio>", views.borrar_anuncio)

def borrar_anuncio(request, id_anuncio):
    código........

<a href ="borrar-anuncio/{{anuncio.id}}"><button>BORRAR</button></a>


TOKEN CSRF

En el caso de uso de formularios , es necesario incorporar a las plantillas un token anti-CSRF que identifique al usuario para
evitar este tipo de ataques, al incluir la siguiente etiqueta, Django genera el token:

{% csrf_token %}

El token debe ir incluido dentro del <form> antes que los inputs

########################################  BASES DE DATOS  #############################################################

Django contiene por defecto un módulo de SQLite y además soporta oficilamente MySQL, PostgreSQL y Oracle,  se pueden añadir
otras como DB2 y SQL Server mediante conectores de terceros

En SQLite Django puede crear las tablas mediante la clase Model

El modelo de BBDD que creemos debe estar obligatoriamente dentro de una aplicación del proyecto (carpeta nombre_aplicacion)

Dentro del archivo models.py debemos crear una clase por cada tabla que deba contener nuestra BBDD ,  mediante estas clases Django construirá automáticamente
todas las sentencias SQL necesarias,  todas las clases deberán heredar de models.Model y habrá que definir los campos según los
métodos heredados

Ej . class Productos(models.Model):
	   nombre = models.CharField(max_lenght = 200)
	   precio = models.FloatField(default = 0)
	   stock = models.IntegerField(default = 0)
	   proveedor = models.ForeignKey(Proveedores, on_delete = models.CASCADE)
	   email_proveedor = models.EmailField(max_length = 100 , unique = True)
	   descuentos = models.BooleanField(default = False)
	   fecha_creacion = models.DateField(blank = True, null = True)  --> Para no se requerido en el panel de administración
									     y admitir registros null
	

Si no se especifica, Djando añade automáticamente un campo Id autoincrementable como primary key, por defecto los campos serán NOT NULL


Para ver los tipos de campos -->  https://docs.djangoproject.com/en/1.10/ref/models/fields/#field-options

Una vez creadas las tablas y la subcarpeta de la app,  esta última hay que registrarla en el archivo settings.py del proyecto, para
ello iremos a la lista INSTALLED_APPS donde añadiremos "nombre_aplicacion.apps.nombre_clase_app" siendo nombre_clase_app el que se haya
creado en el archivo apps.py

Para comprobar que la aplicación está OK,  podemos usar el comando:

python manage.py check nombre_aplicacion

Lo siguiente es crear la BBDD de SQLite:

python manage.py makemigrations

Esto creará el archivo db.sqlite3 y nos dará un número de migración, el primero será el 0001_initial.py

Y ahora ejecutamos lo siguiente para que dentro de db.sqlite3 si apliquen las clases de models.py y se creen las sentencias SQL;

python manage.py sqlmigrate nombre_aplicacion numero_migracion(a ser la primera, 0001)

Siempre que haya que alterar la estrutura de las tablas, modificamos las clases, ejecutamos python manage.py makemigrations 
y en python manage.py sqlmigrate aplicamos el número correspondiente de migración

Por último, ejecutamos las SQL creadas automáticamente mediante este comando:

python manage.py migrate

Y esto deja creadas las nuevas tablas de la BBDD

Para fines de pruebas,  podemos trabajar con la BBDD mediante la linea de comando lanzando la consola de esta manera:

python manage.py shell

Dentro de la consola,  hay que importar la tabla con la que queremos trabajar:

from nombre_aplicacion.models import nombre_clase

Podemos ver las instrucciones SQL que se generan en esta consola accediendo a las variables que usemos de esta manera :

variable.query.__str__()

INSERT

variable = nombre_clase(columna1 = "valor, columna2 = "valor", columna3 = 100 .....etc)  --> Esto genera la sentencia INSERT INTO

variable.save()  --> Guarda el registro

Se puede hacer también en una única instrucción:

variable = nombre_clase.objects.create(columna1 = "valor, columna2 = "valor", columna3 = 100 .....etc) --> INSERT INTO + commit a la vez

UPDATE

Guardamos en una variable la linea que viene de la BBDD para el elemento que deseamos editar ( por ej articulo )

Y luego accedemos al registro en cuestión como una propiedad :

Ej.  articulo.precio = 95 
     articulo.save()       --> Esto actualiza el campo precio a 95

NOTA-  verificar que la ruta que se genera en la URL al guardar el registro modifcado está creada en urlpatterns


DELETE

variable = nombre_clase.objects.get(id = x ) --> Esto guarda en la variable el registro , se puede tomar cualquier campo, pero se recomienda
						 tomar siempre el id

variable.delete()

SELECT

Tenemos que almacenar su contenido en la variable context en forma de diccionario :

Ej.

lista = nombre_clase.objects.all()  --> Esto guarda en lista todos los registros de la tabla como objetos (uno por línea), para acceder al primer
					objeto por ejemplo , lo hariamos con lista[0] , al segundo con lista[1] , etc....

context = {"nombre_variable_en_el_html" : lista}

Y en el HTML podemos recorrer nombre_variable_en_el_html con un bucle FOR usando los nombres de las columnas de la BBDD como propiedades:

{% for i in nombre_variable_en_el_html %}
	{{ i.columna1 }}	
	{{ i.columna2 }}
	....etc

Otras formas de traer la información desde la BBDD:

(Nota- En Django la variable pk representa al campo id --primary key-- de una tabla, se llame como se llame este)


lista = nombre_clase.objects.get(pk = 1) --> Esto trae un único objeto , usar sólo si estamos seguros de que dicho objeto existe

lista = nombre_clase.objects.order_by("-id") --> Esto guarda en lista todos los registros de la tabla ordenados en orden descendente por id

lista = nombre_clase.objects.filter(nombre_campo = valor_de_filtrado) --> Esto guarda en lista los registros filtrados por una clausula WHERE, pero
								       nos trae la información contenida en objetos, uno por cada registro que coincida 
								       con el criquerio valor_de_filtrado. Si necesitamos pasarlos a string, en la
								       la clase con la que fue creada la tabla, hay que definir un método de tipo
								       __str__(self) con un return con el formato que deseemos que presente

lista = nombre_clase.objects.filter(nombre_campo1 = valor_de_filtrado1, nombre_campo1 = valor_de_filtrado1...etc ) --> Como el anterior, añadiendo más
								       más criterios de filtrado con un operador AND


Se pueden concatenar las acciones, por ejemplo nombre_clase.objects.filter(nombre_campo = valor_de_filtrado).order_by("id").count()

Y además podemos evitar SQL pesadas concatenando .prefetch_related("campo_fk1", "campo_fk2".....) --> Evita que Django genere una SQL diferida por cada registro
												      creando una JOIN. Si sólo vamos a traer un registro, podemos
												      podemos hacer la JOIN con select_related(("campo_fk1", "campo_fk2"..)								


Ver documentación oficial de las setencias QuerySet para más información :

https://docs.djangoproject.com/en/3.0/ref/models/querysets/#queryset-api



IMPORTANTE-  Cada vez que modifiquemos algo en models.py , hay que ejecutar los comandos de migración para actualizar las configuraciones:

python manage.py makemigrations
python manage.py migrate

RELACIONES ENTRE TABLAS

Podemos pintar en el template un campo proveniente de otra tabla mediante la Foreign Key:

Ej  class Categoria(models.Model):
        nombre_categoria = models.CharField()  --> Nombre de la categoria

    class Anuncio(models.Model):
        categoria = models.ForeignKey(Categoria,  on_delete = models.CASCADE) --> Id de la categoria en la tabla Categoria

    En el template:
	{% for anuncio in anuncios %}
		{{anuncio.categoria.nombre_categoria}} --> LLamamos al id de la categoria en la tabla Anuncio, pero al llamar
							   a la Foreign Key , se pinta el campo nombre_categoria de la tabla
							   Categoria (usar el nombre los campos en las clases, independientemente
							   de si en la BBDD aparecen con el sufijo _id al ejecutar las migraciones)
	

INSTALAR OTROS GESTORES DE BBDD

PostgreSQL --> Requiere instalar la libreria psycopg2

Luego en settings.py en la lista DATABASES hay que incluir esto :

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql_psycopg2',
        'NAME': 'nombre_base_datos',
	'USER': 'nobre_usuario_de_la_bd',
	'PASSWORD': 'contraseña_de_la_bd',
	'HOST': 'IP_de_la_bd o host_name_de_la_bd',
	'DATABASE_PORT': 'puerto_de_la_bd',
    }
}

La creación de tablas y sentencias SQL es igual a lo anteriormente indicado para SQLite

EJECUCION DIFERIDA Y DEPURACION DE SETENCIAS SQL EN LOCAL

Django genera las sentencias SQL en modo diferido,  primero crea  y no las ejecuta has que hacemos uso de la variable en la que está
almacenado el resultado . Esto permite ir añadiendo en Python lineas de código con filtros posteriores sobre esa misma variable.

Para poder comprobar las setencias SQL que Django ejecuta cuanto lo tenemos instalado aun en local,  podemos añadir a la
vista en cuestión este código para que en la consola aparezcan las SQL que se van generando :
    
    import logging

    l = logging.getLogger('django.db.backends') 
    l.setLevel(logging.DEBUG)
    l.addHandler(logging.StreamHandler())

EVITAR LA GENERACION DE MULTIPLES SQL EN LOS SELECT

En casos en los que necesitamos hacer selects que requieren del uso de Foreign Keys provenientes de otras tablas,  Django
crea una SQL por cada registro,  lo cual puede mermar el rendimiento de nuestra aplicación, para evitar este comportamiento
debemos usar la orden .prefetch_related("campo_fk1", "campo_fk2".....):

EJ.
	lista_objetos_bbdd = models.Anuncio.objects.order_by("-id").prefetch_related('categoria','usuario')

Este ejemplo usará una SQL para extraer el id de sesión (Django siempre lo hace) y otra para traer anuncios ordenados por su id
pintando en lugar del categoria_id y el usuario_id de la clase Anuncio ,  los nombres que tienen estas en las tablas hacia las
que apuntan las Foreigh Keys

#########################################  FORMULARIOS  #################################################################

FORMULARIOS HTML

Método GET

request.GET["name"]

Método POST

request.POST["name"]

Si necesitamos editar contenidos en un formulario,  es necesario incluir el id del elemento a modificar con un <input type = "hidden">,
de esta forma lo podemos leer en Python para identificar correctamente al elemento ya actualizarlo

IMPORTANTE -  La lectura de valores en variables incluidas en las rutas del navegador se hace con el método GET

CSRF - Django no permite el envio de información POST si no se incluye al principo del <form> el Token {% csrf_token %}


########################################  REDIRECCION DE RUTAS  #########################################################

from django.shortcuts import redirect

return redirect("/ruta	_raiz/nombre_ruta")

NOTA:
return render --> Usado para renderizar una determinada template con su context

return redirect --> Para llamar a una determinada ruta al ejecutar una vista

return nombre_vista(request) --> Para llamar a otra vista tras finalizar la ejecución de una vista


#######################################  SESIONES DE USUARIO  ###########################################################

AUTENTICACION DE USUARIOS

Tomaos el usuaro y la contraseña :

usuario_insertado = request.POST["usuario"]
clave_insertada = request.POST["clave"]

Tendremos una clase Usuarios para la tabla de usuarios con el Id de usuario, el nombre de usuario y la clave

Buscamos en dicha tabla lo que leemos en los formularios:

lista_resultado = models.Usuarios.objects.filter(usuario == usuario_insertado, clave == clave_insertada)

La lista de objetos que se crea puede localizar una coincidencia o ninguna en la tabla de usuarios:

if len(resultado == 1):
    usuario = resultado[0] --> Tomamos el objeto usuario de la lista de objetos traida de la BBDD
    request.session["id_usuario"] = usuario.id  --> Ponemos el "sello" de la sesión

Y finalmente, para cerrar la sesión :

request.session.clear()

####################################  ELEMENTOS ESTATICOS  ##############################################################

Para cargar en Django elementos estáticos,  debemos guardarlos en una carpeta llamada static , y en el template HTML debemos
indicar lo siguiente :

Arriba del todo del template 

{% load static %}

Para el CSS

<link rel="stylesheet" href="{% static 'estilos.css' %}"/>

Para el Javascript

<script language="javascript" src="{% static 'javascript.js' %}"></script>

Para las imagenes

<img src = "{% static 'imagen.jpg' %}" />

Y asi cualquier otro elemento estático que deseemos añadir


##################################  BUSCADORES EN LA APLICACION  ##########################################################

Ej.  HTML

buscador:
<form action="/anuncios" method = "GET">

titulo: <input type="text" name="name_valor_en_buscador" value="{{valor_en_buscador}}" /> 

<input type="submit" value="BUSCAR" /> 

<a href="/anuncios">resetear busqueda</a>

</form>

Ej. VIEWS (añadiendo al context valor_en_buscador, se queda pintado en el buscador hasta que se haga un reset)

    resultado = models.Anuncio.objects.order_by("-id").prefetch_related('categoria','usuario')    

    valor_en_buscador = ""

    if "name_valor_en_buscador" in request.GET:

	criterio = request.GET["name_valor_en_buscador"]

        if len(anuncios.filter(columna1__contains = criterio)) != 0:
            anuncios = anuncios.filter(columna1__contains = criterio)

        elif len(anuncios.filter(columna2__contains = criterio)) != 0:
            anuncios = anuncios.filter(columna2__contains = criterio)

	elif len(anuncios.filter(columna3__contains = criterio)) != 0:
            anuncios = anuncios.filter(columna3__contains = criterio)

        etc...

        valor_en_buscador = request.GET["name_valor_en_buscador"] --> Esto va al context para dejarlo pintado en la caja del buscador	 

BUSCADOR EN COLUMAS CON FOREIGN KEYS

Ej. con categorias de anuncios

En este caso hay que localizar primero en la tabla a la que llama la foreign key el texto del id_categoria en el cual estamos buscando

categorias = models.Categorias.objects.filter(columna_con_ForeignKey__contains = criterio)

Luego hay que crear un array que contendrá los objetos finalmente coincidentes

anuncios_finales = []

Y finalmente recorrer con un bucle los objetos que hemos sacado antes desde la tabla Categorias en la variable categorias 
y añadirlos al array

for c in categorias:
    anuncios_finales.extend(anuncios.filter(categoria = c))

anuncios = anuncios_finales


###############################  PAGINACION  #############################################################################

Ej. HTML (usamos en la URL la variable comienzo)

<div>
    
    total de anuncios en base de datos: {{total_resultados}} <br/>
    
    {% if anterior >= 0 %}
        <a href="/anuncios?comienzo={{anterior}}">ANTERIOR</a>
    {% endif %}
    
    {% if siguiente < total_resultados %}
        <a href="/anuncios?comienzo={{siguiente}}">SIGUIENTE</a>
    {% endif %}
</div>

Ej. VIEWS ( caso de 5 resultados por página haciendo un slice a la lista de objetos que viene de la BBDD)

    listado = models.Anuncio.objects.order_by("-id").prefetch_related('categoria','usuario')

    comienzo = 0
    if "comienzo" in request.GET :
        comienzo = int(request.GET["comienzo"])
    listado = listado[comienzo:comienzo+5]
    total_resultados = models.Anuncio.objects.count()    
    
    siguiente = comienzo + 5
    anterior = comienzo - 5
    context = {
            "anuncios" : listado,
            "valor_en_buscador" : valor_en_buscador,
            "siguiente" : siguiente,
            "anterior" : anterior,
            "total_resultados": total_resultados
	    }


############################ SUBIR PROYECTOS DJANGO A PYTHON ANYWHERE  ###############################################

Al crear un poryecto Django en PythonAnywhere , se crean automáticamente los archivos settins.py y urls.py del proyecto,
con lo cual nosotros sólo debemos subir el contenido de la carpeta donde se encuentre nuestra APP, creando el directorio
con el nombre de dicha APP y las subcarpetas static, templates......

Una vez subidos los archivos, en settings.py debemos añadir a la ilsta INSTALLED_APPS nuestra APP y crear la BD de MySQL,
añadiendola a la lista DATABASES de settings.py , también hay que poner el DEBUG a False, ya que en el debugging sólo se
puede hacer en local

En urls.py de la raiz del proyecto añadiremos con include la ruta de la raiz que vayamos a usar

Finalmente, en la consola BASH ejecutamos estas sentencias ( en este caso con Python 3.8)

python3.8 manage.py makemigrations nombre_app

python3.8 manage.py migrate

Con esto nuestro proyecto Django ya está listo para trabajar con él



############################  IMAGENES Y ARCHIVOS  ##################################################################

Este código permite guardar una imagen o cualquier otra clase de archivo, como un PDF

En el HTML :

Para subir imagenes

<form action = "guardar-nuevo-anuncio" method="post" enctype="multipart/form-data">

	 <input type="file" name="foto"/>

Para mostrar imagenes, en la parte de arriba del <body> incluimos esto 

{% load static %}
{% static 'nombre_carpeta_imagenes' as ruta_imagenes %}

Y para que aparezca la imagen

<img src="{{ruta_imagenes}}/{{elemento.id}}.jpg" />

En el VIEWS

from django.core.files.storage import default_storage
from django.core.files.base import ContentFile

#Guardamos una imagen nombrandola con el id en BBDD del registro al que hace referencia en el directorio static

    id_anuncio = anuncio.id --> Viene de un objeto obtenido de la BBDD
    ruta = "anuncios/static/imagenes/" + str(id_anuncio) + ".jpg"
    f = request.FILES["foto"]
    default_storage.save(ruta, ContentFile(f.read()))   

COMPROBAR SI HAY UNA IMAGEN O ARCHIVO PARA CARGAR :

if "imagen" in request.FILES:
    imagen = request.FILES["imagen"]
    código......

SUSTITUCION DE ARCHIVOS EXISTENTES

El método default_storage.save() no "machaca" archivos existentes con el mismo nombre,  primero es necesario usar
os.path.isfile() y os.remove() para borrar el archivo existente y luego guardar el nuevo con el mismo nombre


############################  PANEL DE ADMINISTRACION  ##############################################################

La web de administracion que incorpora Django está en la ruta /admin que aparece en el archivo urls.py de la raiz del
proyecto

Para visualizar las tablas de la BBDD en este portal, hay que incluir las clases con las que las hemos creado en el archivo
admin.py de nuestra APP de esta manera:

from . import models

admin.site.register(models.nombre_clase)

IMPORTANTE -  En el Panel de administracion se añade una s al final del nombre de la clase , por lo que habria que evitar
crear modelos con nombres en plural

También es conveniente añadir las clases un método __str__(self) en el cual definamos un string que muestre la información
contenida en las clases que queramos que aparezca en el listado del panel de administración, de lo contrario aparece un
listado con números de objetos:

Ej __str__(self):
       return "El usuario se llama {} {} {}".format(self.nombre, self.apellido1, self.apellido2)

Por último , hay que crear el superusuario administrador del portal, que a su vez podrá crear otros administradores:

python manage.py createsuperuser


En el panel aparecen los campos de las tablas creadas en models.py nombrados con la priemra letra en mayuscula y cambiando
los guiones bajos por un espacio.  Si por alguna razón necesitamos que se pinte en el panel el nombre de algún campo con
otro nombre disinto, basta con añadir esto en el propiedad de la clase:

nombre = models.CharField(max_length = 20, verbose_name = "Nombre de Usuario")

Podemos personalizar los campos de los modelos que se muestran en el panel, para ello en admin.py hay que crear una clase
que , heredando de admin.ModelAdmin, indique los campos que serán visibles del modelo en cuestión;


	class nombre_claseAdmin(admin.ModelAdmin):
		list_display = ("nombre_campo1", "nombre_campo2"....)
		search_fields = ("nombre_campo1", "nombre_campo2"....) --> Estos son campos por los cuales buscar en el panel
		list_filter = ("nombre_campo1", "nombre_campo2"....) --> Estos son campos por los cuales filtrar en el panel
		date_hierarchy = ("campo_fecha",) --> Esto añade menús de selección de fechas en la parte superior del panel

Y actualizar el registro:

admin.site.register(nombre_clase, nombre_claseAdmin)

De esta manera en el panel se muestra sólo lo añadido en la clase que enmascara a la real, y además se añade un buscador en el
panel y un filtro ( si usamos un campo DateField, Django añade varios filtros por dias, meses, años...)









