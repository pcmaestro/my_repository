pip install django  (con pip install django == nº_version podemos instalar la versión que queramos, por defecto se instala la última)

python -m django --version


Los proyectos de Django se dividen en tres partes (MVT) :

Model --> Bases de datos

View -->  Funciones Python

Templates --> Plantillas HTML

Si queremos nuestros proyectos en un entorno virtual, lo podmeos hacer de dos maneras :

PYCHARM - El IDE Pycharm permite crear un entorno virtual para cada proyecto

MANUALMENTE - python -m venv nombre_entorno_virtual --> se crea un archivo activate.bat que debemos ejecutar

Una vez creado el entorno virtual, si la instalación de Django la hemos hecho de forma global, deberemos volver a instalarlo en dicho
entorno virtual


##########################################  CREAR UN PROYECTO  ####################################################################

- Creamos la carpeta de proyectos para Django en nuestro IDE,  luego dentro de esta hay que crear una carpeta de proyecto en la consola
de este modo:

django-admin startproject nombre_proyecto

Esto crea la carpeta nombre_proyecto y colgando de ella una subcarpeta de archivos de proyecto con el mismo nombre y el archivo manage.py
que contiene los comandos de Django

Dentro de la subcarpeta hay varios archivos importantes, entre ellos:

settings --> Contiene las configuraciones del proyecto, aqui está la lista de INSTALLED_APPS con las app
	     que vienen de serie, y en la cual debemos incluir las apps que vayamos creando para el proyecto

urls.py --> Contiene las rutas

Dentro de la carpeta de proyecto , en la linea de comandos ejecutamos esto:

python manage.py migrate --> Si no queremos SQLite, primero modificar el settings para la BD deseada

Esto crea el archivo db.sqlite3 para la base de datos (luego se pueden modificar configuraciones para conectar con otras)

-Comprobamos que el proyecto arranca usando el servidor interno de django (servidor sólo util para comprobaciones, no para producción):

python manage.py runserver

La URL que nos da la podemos cargar en el navegador para ver que el proyecto está arrancado

- El proyecto estará dividido en varias apps, por convenciòn se crea un paquete python llamado apps y se van creando las aplicaciones dentro
  de él, si no tenemos un IDE que pueda crear paquetes python, basta con crear una carpeta e incluir un archivo en blanco llamado __init__.py
  El comando para crear una aplicación es el siguiente:
	
	django-admin.py startapp nombre_app --> si sólo vamos a tener una aplicación, no hace falta crear el paquete apps y entonces podemos
						crear la aplicación con python manage.py startapp nombre_app

Esto crea otra subcarpeta con el nombre de la app, y dentro a su vez se creará otra subcarpeta llamada migrations y varios archivos:

models.py --> Contiene las clases para crear las tablas en la BBDD

views.py --> Contiene las funciones Python asociadas a las rutas web

apps.py  --> Contiene la clase de nuestra nueva app

-Una vez creada la mueva app,  hay que incluirla en la lista INSTALLED_APPS del archivo settings.py de la subcarpeta principal nombre_proyecto.
Para hacerlo, necesitamos saber el nombre de clase que se ha creado para nuestra app en el archivo apps.py de la subcarpeta nombre_app

Ej.

INSTALLED_APPS = [
    'nombre_app.apps.nombre_clase', --> tener en cuenta en la ruta si hemos creado o no el paquete app
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
]

La recepción y envio de información en el VIEW se hace con objetos de las clases Request (recepción) y HttpResponse (envío)

Dentro del archvio views.py hacemos esta importación:

from django.http import HttpResponse

En este archivo se contienen lo que Django llama "vistas" , que son funciones Python , estas funciones deben recibir siempre como 
parametro el objeto request , y luego pueden recibir parametros adicionales

Ej.  def inicio(request , posible_parametro_adicional):
         return HttpResponse("Hola Mundo")

Para cada "vista" que creemos que en el views.py , debemos asignarle una ruta en el archivo urls.py

Es buena práctica crear un urls.py para cada proyecto/app y luego llamarlo desde el urls.py de la subcarpeta principal del proyecto
de esta manera:

Ej.  

from django.urls.conf import include

urlpatterns = [
    path('nombre_app/',include("nombre_app.urls")),  --> Si sólo tenemos una app, podemos dejar la ruta como ""
    path('admin/', admin.site.urls),
]

Y luego en el urls.py que hayamos creado en la carpeta nombre_app:

from . import views
from django.urls import path

urlpatterns = [
    path("", views.nombre_funcion_inicio_pagina),
    path("nombre_ruta/", views.nombre_funcion_asociada_a_la_ruta)
    ]

Si la ruta la dejamos vacia con "" , definimos una raiz a partir de la ruta "padre/" que hayamos definido en el archivo urls.py de la
carpeta principal nombre_proyecto

El archvio urls.py contiene una lista con las rutas de nuestro proyecto, ahi debemos incluir las rutas para las vistas que
vayamos creando (haciendo la pertinente importación) el formato de la ruta será este:

from nombre_app.views import nombre_vista

path("nombre_ruta/" , nombre_vista)

En las rutas se pueden incluir parámetros mediante la notación <parámetro> ,  por defecto lo que se indique será string, si por
ejemplo queremos pasar un número, la notaación será "nombre_ruta/<int:parámetro>" .  Los parámetros que pasemos por URL deben
ser recogidos por la vista

Ej.  path("ruta1/<parametro_string>/<int:parametro_numerico>/" , funcion_vista)

     def funcion_vista(request, parametro_string, parametro_numerico):
         código.............

------------------------------------  RESOLUCION INVERSA DE RUTAS  -------------------------------------------------

En el urlpatterns podemos incluir un argumento "name" con el cual invocar fácilmente desde los templates a la ruta en cuestión y ejecutar
su función asociada:

Ej en el urlpatterns

path("articulos/<int:year>", views.achivo_historico , name = "archivo-historico")

Ej en el HTML

<a href = "{% url 'archivo-historico' variable_year %}> ARCHIVO HISTORICO DE NOTICIAS </a>


Esto nos permite no necesitar modificar los templates si modificamos cosa en el views , simplemente hay que mantener el mismo name


También se puede usar en el views, en este ejemplo hacemos una redirección de ruta usando la función reverse():


def redirect_to_year(request):
    código...
    year = 2006
    return redirect( reverse("archivo-historico", args = (year,) )


Es una buena práctica nombrar los "name" haciendo mención a la app a la que corresponden,  para poder tenerlo todo ordenado y facil de
identificar , en el ejemplo indicado podría ser myapp-archivo-historico


---------------------------------------------  NAMESPACE  --------------------------------------------------------------------

Las rutas con namespace se invocan el formato nombre_app:name_en_el_views , en este ejemplo tenemos la app llamada polls (se usan class-based-views);

urls.py
from django.urls import include, path

urlpatterns = [
    path('polls/', include('polls.urls')),
]


polls/urls.py
from django.urls import path

from . import views

app_name = 'polls'  --> imprescindible incluir esto en el urls.py
urlpatterns = [
    path('', views.IndexView.as_view(), name='index'),
    path('<int:pk>/', views.DetailView.as_view(), name='detail'),
    ...
]

En este caso en el template podemos llamar a la ruta con name = detail indicando -->  {% url 'polls:detail' %}



-----------------------------------  RUTAS CON EXPRESIONES REGULARES  ---------------------------------------------------------

from django.urls import re_path

Con esto podemos crear patrones de URLs que en caso de coincidencia a la hora de escribir una URL, llamará a una función determinada
del views . La sintaxis para crear grupos de expresiones regulares es (?P<name>pattern) ,  donde name es la variable que pasamos al 
views y pattern es el patrón que debe cumplir, por ejemplo, en estos dos urlpatterns estamos indicando lo mismo:

urlpatterns = [
    path('articles/2003/', views.special_case_2003),
    path('articles/<int:year>/', views.year_archive),
    path('articles/<int:year>/<int:month>/', views.month_archive),
    path('articles/<int:year>/<int:month>/<slug:slug>/', views.article_detail),
]

urlpatterns = [
    path('articles/2003/', views.special_case_2003),
    re_path(r'^articles/(?P<year>[0-9]{4})/$', views.year_archive),
    re_path(r'^articles/(?P<year>[0-9]{4})/(?P<month>[0-9]{2})/$', views.month_archive),
    re_path(r'^articles/(?P<year>[0-9]{4})/(?P<month>[0-9]{2})/(?P<slug>[\w-]+)/$', views.article_detail),


Como podemos ver en el ejemplo, el formato regexp del urlpatterns es el siguiente:

re_path(r'^(?P<name>pattern)/(?P<name>pattern)/(?P<name>pattern)$' , views.nombre_vista) --> En el path no tienen por qué ser todo regexp

Hay que tener en cuenta que con este método, todo lo que enviamos al views va en formato str , con lo cual quizá sea necesario transformarlo
en el views para poder usarlo

ARGUMENTOS ANIDADOS

Puede ocurrir que en una ruta, el views sólo necesite capturar una parte del path,  pera estos casos, se pueden usar las expresiones regulares
de la siguiente manera:


re_path(r'^comments/(?:page-(?P<page_number>\d+)/)?$', comments)

En este caso el path comments/page-32 sería válido , como podemos ver, el formato es (?:parte_irrelevante_en_views(variable_relevante_en_views)),
el simbolo ? que cierra toda la regexp es para indicar que puede haber una o ninguna coincidencia con la ruta

AGREGACION DE RUTAS

Podemos agregar fácilmente rutas en urlpatters haciendo uso de include , por ejemplo, estos dos urlpatterns son equivalentes:

from django.urls import include

urlpatterns = [
    path('<page_slug>-<page_id>/history/', views.history),
    path('<page_slug>-<page_id>/edit/', views.edit),
    path('<page_slug>-<page_id>/discuss/', views.discuss),
    path('<page_slug>-<page_id>/permissions/', views.permissions),
]


urlpatterns = [
    path('<page_slug>-<page_id>/', include([
        path('history/', views.history),
        path('edit/', views.edit),
        path('discuss/', views.discuss),
        path('permissions/', views.permissions),
    ])),
]




#####################################  TEMPLATES  ##################################################################################

Dentro de la subcarpeta del proyecto, creamos la subcarpeta templates e incluimos en ella todas las plantillas HTML

Para renderizar las plantillas, en las vistas de view.py devolvemos lo siguiente :

return render(request, "nombre_plantilla.html")

Si además traemos datos desde una BBDD hay que añadir la variable context ( contenido dinámico) :

return render(request, "nombre_plantilla.html", context)

La vaiable context contiene un diccionario donde indicamos como clave el nombre de la variable que mostramos en los {{ }} del HTML
y como valor lo que contenga dicha variable.  Recordar que como valor también se pueden pasar objetos iterables

Ej.  Traemos un listado de anuncios desde la BBDD

def inicio(request):
    resultado = models.Anuncio.objects.order_by("-id")
    context = { "anuncios" : resultado }
    return render(request, "index.html", context)

En las anotaciones {{ }} podemos incluso trear propiedades de objetos ( {{ objeto.propiedad }} ) y también sus métodos ( {{ objeto.metodo }} )
que en este caso no deben cerrarse con ()

Para usar bucles y condicionales,  hay que usar la notación {%  %} .....  {%end...%}

Dentro de estas anotaciones Jinja se pueden aplicar filtros usando el símbolo pipe | 

Ej.  nombre = Juan

     {{ nombre|first|lower }}  -->  j 


También podemos incrustar plantillas HTML dentro de otra plantilla 

{% include "sub_plantilla.html" %}

Y podemos usar HERENCIA DE PLANTILLAS creando un plantilla base.html e invocandola en las hijas mediante

{% extends "base.html" %}

En la plantilla base hay que definiar los bloques cambiantes:

Para el título --> <title> {% block title %}  {% endblock %} </title>

Para el contenido  --> <body> {% block content %}  {% endblock %} </body>

Y estos mismos bloques son invocados en las plantillas hijas detrás de {% extends "base.html" %} para personalizar su contenido
HTML individual , donde podremos incluso incrustar otras plantillas con {% include "sub_plantilla.html" %}

tanto para usar extends como include, tener encuenta si la plantilla en cuestión está en la misma ruta que la que hereda , o
en otra distinta, ya que en caso afirmativo, habrá que indicarla en la expresión , por ej , {% extends "base/base.html" %}

URL LINKING

En la lista urlpatterns podemos añadir un "name" que nos servirá para llamar al función del views mediante URL linking

Ej.

urlpatterns[ "lista-articulos", views.listado_articulos, name = "lista" ]


<a href = "{% url 'lista' %}"> LISTADO DE ARTICULOS </a>


En este enlace se ejecutará la función views.listado_articulos y renderizará el template que le corresponda . Esta forma de llamar
a las funciones, nos permite modificar el nombre de la función o incluso la ruta sin modificar nada en el HTML, ya que este siempre
buscará el "name" en el urlpatterns


CARGADOR DE PLANTILLAS

from django.template import loader

En el archivo settings.py hay un diccionario dentro de TEMPLATES que contiene "DIRS : []" , ahi podemos incluir la ruta hacia la carpeta
que contiene nuestras plantillas , ej "DIRS : ["./templates"] , tras esto en la vista podemos almacenar la plantilla en una variable de
esta manera :

doc_plantilla = loader.get_template("nombre_plantilla.html")

Y tras definir el diccionario contenido en el context,  la podemos renderizar de esta manera:

documento = doc_plantilla.render(context)
return HttpResponse(documento)

Pero tenemos también la opción más rápida de usar el módulo render de las shortcuts functions de Django:

from django.shorcuts import render

return render(request, "nombre_plantilla_html", context) --> Este método requiere que exista una carpeteta templates en la 
							     subcarpeta del proyecto

PARAMETROS EN URL

A parte de las conocidas anotaciones ? y & ,  Django permite pasar variables "url friendly" a través de las URL de las rutas suando 
la anotación <variable>. Por defecto,  esta variable contiene un string, si es necesario un número entero habria que indicar <int:variable> 
y si es un número real sería <float:variable>

La vista que deba procesar la variable , deberá recibirla como argumento , y en la llamada a la ruta en el HTML por ejemplo en un botón,
podemos sustituir su valor por un contenido entre {{}}:

Ej

path("borrar-anuncio/<id_anuncio>", views.borrar_anuncio)

def borrar_anuncio(request, id_anuncio):
    código........

<a href ="borrar-anuncio/{{anuncio.id}}"><button>BORRAR</button></a>


TOKEN CSRF

En el caso de uso de formularios , es necesario incorporar a las plantillas un token anti-CSRF que identifique al usuario para
evitar este tipo de ataques, al incluir la siguiente etiqueta, Django genera el token:

{% csrf_token %}

El token debe ir incluido dentro del <form> antes que los inputs

########################################  BASES DE DATOS (QUERYSETS) #############################################################

Django contiene por defecto un módulo de SQLite y además soporta oficilamente MySQL, PostgreSQL y Oracle,  se pueden añadir
otras como DB2 y SQL Server mediante conectores de terceros . Se cual sea el que usemos, la BD la tenemos que crear siempre
en blanco (y configurarlas en el settings) , ya que las tablas será creadas por el models.py . Por defecto Django crea 10
tablas por defecto con contenido interno

En SQLite Django puede crear las tablas mediante la clase Model

El modelo de BBDD que creemos debe estar obligatoriamente dentro de una aplicación del proyecto (carpeta nombre_aplicacion)

Dentro del archivo models.py debemos crear una clase por cada tabla que deba contener nuestra BBDD ,  mediante estas clases Django construirá automáticamente
todas las sentencias SQL necesarias,  todas las clases deberán heredar de models.Model y habrá que definir los campos según los
métodos heredados

Ej . class Productos(models.Model):
	   nombre = models.CharField(max_lenght = 200)
	   precio = models.FloatField(default = 0)
	   stock = models.IntegerField(default = 0)
	   proveedor = models.ForeignKey(Proveedores, on_delete = models.CASCADE) --> Como habrá muchos proveedores, podemos usar
										      también models.ManyToManyField(Proveedores),
										      que apuntaría hacia la clase Proveedores
	   email_proveedor = models.EmailField(max_length = 100 , unique = True)
	   descuentos = models.BooleanField(default = False)
	   fecha_creacion = models.DateField(blank = True, null = True)  --> Para no ser requerido en el panel de administración
									     y admitir registros null

	   imagen = models.ImageField(upload_to = "images") --> La carpeta images se crea automáticamente dentro de media

	   class Meta: --> Opcional para metadatos, ver https://docs.djangoproject.com/en/3.0/ref/models/options/

		constraints = [models.CheckConstraint(check=models.Q(precio__lte=500), name='precio_lte_500')]
		indexes = [models.Index(fields= ["nombre"], name = "nombre_idx")
		ordering = ["-precio"]
		db_table = "nombre_personalizado_de_la_tabla"
		etc......
		
	

Si no se especifica, Djando añade automáticamente un campo Id autoincrementable como primary key, por defecto los campos serán NOT NULL ,
si queremos definir nosotros el primary key , seria por ej id_producto = models.CharField(primary_key = True)


Para ver los tipos de campos -->  https://docs.djangoproject.com/en/1.10/ref/models/fields/#field-options

Si necesitamos campos que acepten registros null , añadir a los argumentos null = True

Si necesitamos campos que se puedan guardar sin que el usuario haya guardado nada ,  required = False, blank = True

Una vez creadas las tablas y la subcarpeta de la app,  esta última hay que registrarla en el archivo settings.py del proyecto, para
ello iremos a la lista INSTALLED_APPS donde añadiremos "nombre_aplicacion.apps.nombre_clase_app" siendo nombre_clase_app el que se haya
creado en el archivo apps.py

Para comprobar que la aplicación está OK,  podemos usar el comando:

python manage.py check nombre_aplicacion

Lo siguiente es crear la BBDD de SQLite:

python manage.py makemigrations

Esto creará el archivo db.sqlite3 y nos dará un número de migración, el primero será el 0001_initial.py

Y ahora ejecutamos lo siguiente para que dentro de db.sqlite3 si apliquen las clases de models.py y se creen las sentencias SQL;

python manage.py sqlmigrate nombre_aplicacion numero_migracion(a ser la primera, 0001)

Siempre que haya que alterar la estrutura de las tablas, modificamos las clases, ejecutamos python manage.py makemigrations 
y en python manage.py sqlmigrate aplicamos el número correspondiente de migración

Por último, ejecutamos las SQL creadas automáticamente mediante este comando:

python manage.py migrate

Y esto deja creadas las nuevas tablas de la BBDD

Para fines de pruebas,  podemos trabajar con la BBDD mediante la linea de comando lanzando la consola de esta manera:

python manage.py shell

Dentro de la consola,  hay que importar la tabla con la que queremos trabajar:

from nombre_aplicacion.models import nombre_clase

Podemos ver las instrucciones SQL que se generan en esta consola accediendo a las variables que usemos de esta manera :

variable.query.__str__()

INSERT

variable = nombre_clase(columna1 = "valor, columna2 = "valor", columna3 = 100 .....etc)  --> Esto genera la sentencia INSERT INTO

variable.save()  --> Guarda el registro

Se puede hacer también en una única instrucción:

variable = nombre_clase.objects.create(columna1 = "valor, columna2 = "valor", columna3 = 100 .....etc) --> INSERT INTO + commit a la vez

UPDATE

Guardamos en una variable la linea que viene de la BBDD para el elemento que deseamos editar ( por ej articulo )

Y luego accedemos al registro en cuestión como una propiedad :

Ej.  articulo.precio = 95 
     articulo.save()       --> Esto actualiza el campo precio a 95

NOTA-  verificar que la ruta que se genera en la URL al guardar el registro modifcado está creada en urlpatterns


DELETE

variable = nombre_clase.objects.get(id = x ) --> Esto guarda en la variable el registro , se puede tomar cualquier campo, pero se recomienda
						 tomar siempre el id

variable.delete()

SELECT

Tenemos que almacenar su contenido en la variable context en forma de diccionario :

Ej.

lista = nombre_clase.objects.all()  --> Esto guarda en lista todos los registros de la tabla como objetos (uno por línea), para acceder al primer
					objeto por ejemplo , lo hariamos con lista[0] , al segundo con lista[1] , etc....

context = {"nombre_variable_en_el_html" : lista}

Y en el HTML podemos recorrer nombre_variable_en_el_html con un bucle FOR usando los nombres de las columnas de la BBDD como propiedades:

{% for i in nombre_variable_en_el_html %}
	{{ i.columna1 }}	
	{{ i.columna2 }}
	....etc

Otras formas de traer la información desde la BBDD:

(Nota- En Django la variable pk representa al campo id --primary key-- de una tabla, se llame como se llame este)


lista = nombre_clase.objects.get(pk = 1) --> Esto trae un único objeto , usar sólo si estamos seguros de que dicho objeto existe

lista = nombre_clase.objects.order_by("-id") --> Esto guarda en lista todos los registros de la tabla ordenados en orden descendente por id

lista = nombre_clase.objects.filter(nombre_campo = valor_de_filtrado) --> Esto guarda en lista los registros filtrados por una clausula WHERE, pero
								       nos trae la información contenida en objetos, uno por cada registro que coincida 
								       con el criquerio valor_de_filtrado. Si necesitamos pasarlos a string, en la
								       la clase con la que fue creada la tabla, hay que definir un método de tipo
								       __str__(self) con un return con el formato que deseemos que presente

lista = nombre_clase.objects.filter(nombre_campo = valor_de_filtrado).count() --> Cuenta los registros obtenidos

lista = nombre_clase.objects.filter(nombre_campo__contains = valor_contenido) --> Filtra los registros según un valor X que contengan, si usamos
										  icontains la busqueda es case-insensitive

lista = nombre_clase.objects.filter(nombre_campo = valor_de_filtrado).distinct() --> Filtra los registros haciendo un select distinct

lista = nombre_clase.objects.filter(nombre_campo__gt = 100) --> Filtra los registros por valores mayores que 100

lista = nombre_clase.objects.filter(nombre_campo__lt = 100) --> Filtra los registros por valores menores que 100

lista = nombre_clase.objects.filter(nombre_campo__gte = 100) --> Filtra los registros por valores iguales o mayores que 100

lista = nombre_clase.objects.filter(nombre_campo__lte = 100) --> Filtra los registros por valores iguale o menores que 100

lista = nombre_clase.objects.filter(nombre_campo__in = [array]) --> Filtra los registros que existan dentro de un array

lista = nombre_clase.objects.filter(nombre_campo1 = valor_de_filtrado1, nombre_campo1 = valor_de_filtrado1...etc ) --> Como el anterior, añadiendo más
								       criterios de filtrado con un operador AND

lista = nombre_clase.object.aggregate(nombre_campo1 , nombre_campo2)  --> Devuelve valores agregados de los campos indicados


Se pueden concatenar las acciones, por ejemplo nombre_clase.objects.filter(nombre_campo = valor_de_filtrado).filter(nombre_campo__contains = valor_contenido).count() 

Y además podemos evitar SQL pesadas concatenando .prefetch_related("campo_fk1", "campo_fk2".....) --> Evita que Django genere una SQL diferida por cada registro
												      creando una JOIN. Si sólo vamos a traer un registro, podemos
												      podemos hacer la JOIN con select_related(("campo_fk1", "campo_fk2"..)								


Ver documentación oficial de las setencias QuerySet para más información :

https://docs.djangoproject.com/en/3.0/ref/models/querysets/#queryset-api



IMPORTANTE-  Cada vez que modifiquemos algo en models.py , hay que ejecutar los comandos de migración para actualizar las configuraciones:

python manage.py makemigrations
python manage.py migrate

RELACIONES ENTRE TABLAS

Muchos a uno - ForeignKey:

Un registro uno a muchos sería por ejemplo un usuario que ha publicado varios anuncios

Podemos pintar en el template un campo proveniente de otra tabla mediante la Foreign Key

Ej  class Categoria(models.Model):
        nombre_categoria = models.CharField()  --> Nombre de la categoria

    class Anuncio(models.Model):
        categoria = models.ForeignKey(Categoria,  on_delete = models.CASCADE) --> Id de la categoria en la tabla Categoria

    En el template:
	{% for anuncio in anuncios %}
		{{anuncio.categoria.nombre_categoria}} --> LLamamos al id de la categoria en la tabla Anuncio, pero al llamar
							   a la Foreign Key , se pinta el campo nombre_categoria de la tabla
							   Categoria (usar el nombre los campos en las clases, independientemente
							   de si en la BBDD aparecen con el sufijo _id al ejecutar las migraciones)

Uno a uno - OneToOneField:

	En este caso es un registro que apunta únicamente hacia otra tabla, por ej, un anunciante sólo puede tener una cuanta bancaria
	
	cuenta_anunciante = models.OneToOneField(CuentaBancaria , max_length = 20)

Muchos a muchos - ManyToManyField
	
	Esto requiere de la existencia de una tabla intermedia que contenga los id de los modelos relacionados . Por ejemplo , tenemos
	por un lado varios niños y varias vacunas ,  cada niño puede tener puestas varias vacunas, y cada vacuna puede estar puesta en
	varios niños

	class Vacuna(models.Model):
		nombre_vacuna = models.CharField(max_length = 50)		
	
	class Kid(models.Model):
		nombre_kid = models.CharField(max_length = 50)
		vacuna_recibida = models.ManyToManyField(Vacuna)
	
	Django crea automáticamente la tabla intermadia con los id de las tablas relacionadas


INSTALAR OTROS GESTORES DE BBDD

PostgreSQL --> Requiere instalar la libreria psycopg2

Luego en settings.py en la lista DATABASES hay que incluir esto :

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql_psycopg2',
        'NAME': 'nombre_base_datos',
	'USER': 'nobre_usuario_de_la_bd',
	'PASSWORD': 'contraseña_de_la_bd',
	'HOST': 'IP_de_la_bd o host_name_de_la_bd',
	'PORT': 5432
    }
}

MySQL -->

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.mysql',
        'NAME': 'nombre_base_datos',
        'USER' : 'usuario_bd',
        'PASSWORD' : 'password_bd',
        'HOST' : 'IP_de_la_bd o host_name_de_la_bd',
        'PORT' : 3306
    }
}

La creación de tablas y sentencias SQL es igual a lo anteriormente indicado para SQLite

EJECUCION DIFERIDA Y DEPURACION DE SETENCIAS SQL EN LOCAL

Django genera las sentencias SQL en modo diferido,  primero crea  y no las ejecuta has que hacemos uso de la variable en la que está
almacenado el resultado . Esto permite ir añadiendo en Python lineas de código con filtros posteriores sobre esa misma variable.

Para poder comprobar las setencias SQL que Django ejecuta cuanto lo tenemos instalado aun en local,  podemos añadir a la
vista en cuestión este código para que en la consola aparezcan las SQL que se van generando :
    
    import logging

    l = logging.getLogger('django.db.backends') 
    l.setLevel(logging.DEBUG)
    l.addHandler(logging.StreamHandler())

EVITAR LA GENERACION DE MULTIPLES SQL EN LOS SELECT AL HACER JOIN

En casos en los que necesitamos hacer selects que requieren del uso de Foreign Keys provenientes de otras tablas,  Django
crea una SQL por cada registro,  lo cual puede mermar el rendimiento de nuestra aplicación, para evitar este comportamiento
debemos usar la orden .prefetch_related("campo_fk1", "campo_fk2".....):

EJ.
	lista_objetos_bbdd = models.Anuncio.objects.order_by("-id").prefetch_related('categoria','usuario')

Este ejemplo usará una SQL para extraer el id de sesión (Django siempre lo hace) y otra para traer anuncios ordenados por su id
pintando en lugar del categoria_id y el usuario_id de la clase Anuncio ,  los nombres que tienen estas en las tablas hacia las
que apuntan las Foreigh Keys. Si sabemos que sólo obtendremsos un unico registro, podemos usar select_related()

USO DE QUERYS CON EL METODO RAW

Si en el models.py creamos este modelo :

class Person(models.Model):
    first_name = models.CharField(...)
    last_name = models.CharField(...)
    birth_date = models.DateField(...)

en la BBDD se creará tabla llamada nombre_app_person:

>>> for p in Person.objects.raw('SELECT * FROM myapp_person'):
...     print(p)
John Smith
Jane Jones

MANAGERS

Una manager es la inferfaz a través de la cual son provistas las queries de SQL en los modelos de Django

Cada modelo tiene al menos un manager, que por defecto se llama objects ,  para invocar sus métodos la sintaxis
es Mi_clase.objects.metodo()

Podemos sobreescribir los métodos del Manager heredando de la clase models.Manager para personalizar nuestros propios
querysets añadiendo al cursor nuestras propias querys de SQL

Ej. añadiendo un método a la clase models.Manager para crear un queryset personalizado llamado with_counts()

from django.db import models

class PollManager(models.Manager):
    def with_counts(self):
        from django.db import connection
        with connection.cursor() as cursor:
            cursor.execute("""
                SELECT p.id, p.question, p.poll_date, COUNT(*)
                FROM polls_opinionpoll p, polls_response r
                WHERE p.id = r.poll_id
                GROUP BY p.id, p.question, p.poll_date
                ORDER BY p.poll_date DESC""")
            result_list = []
            for row in cursor.fetchall():
                p = self.model(id=row[0], question=row[1], poll_date=row[2])
                p.num_responses = row[3]
                result_list.append(p)
        return result_list

class OpinionPoll(models.Model):
    question = models.CharField(max_length=200)
    poll_date = models.DateField()
    objects = PollManager()

class Response(models.Model):
    poll = models.ForeignKey(OpinionPoll, on_delete=models.CASCADE)
    person_name = models.CharField(max_length=50)
    response = models.TextField()	

Con esto podemos usar el queryset personalizado OpinionPoll.objects.with_counts()

#########################################  FORMULARIOS  #################################################################

FORMULARIOS HTML

Método GET

request.GET["name"]

Método POST

request.POST["name"]

Si necesitamos editar contenidos en un formulario,  es necesario incluir el id del elemento a modificar con un <input type = "hidden">,
de esta forma lo podemos leer en Python para identificar correctamente al elemento ya actualizarlo

IMPORTANTE -  La lectura de valores en variables incluidas en las rutas del navegador se hace con el método GET

CSRF - Django no permite el envio de información POST si no se incluye al principo del <form> el Token {% csrf_token %}


-------------------------------------------  API FORMS  --------------------------------------------------------------

Django incorpora un módulo para la creación y validación de formularios

Debemos crear un módulo python específico en el mismo directorio donde estén ubicados los views

forms.py

Y dentro de este módulo debemos crear la clase que construirá los formularios ( una clase por cada formulario ), las instancias
de dicha clase serán objetos HTML en formato de lineas de tabla que podremos incluir en nuestros templates envueltas en un <form><table>


Ej. con un formulario de contacto (método raw)


from django import forms

class FormularioContacto(forms.Form):
	
	asunto = forms.CharField()
	email = forms.EmailField()
	message = forms.CharField(widget=forms.Textarea)

Ej. con un formulario de contacto (método Model)  -->  RECOMENDADO

from django import forms
from . import models

class FormularioContacto(forms.ModelForm):
	asunto = forms.CharField(initial = "Hola Mundo") --> opcional, para sobreescribir en un campo lo que viene del models
	class Meta:
		model = models.Nombre_clase
		fields = "__all__" --> o también ["asunto", "email", "mensaje"]
		widgets = {
			"asunto" : forms.TextInput(attrs=("id":"id_asunto","required":True,"placeholder":"Asunto del mensaje")),
			"email" : forms.EmailInput(attrs=(ming_length = 6),
			"mensaje" : forms.Textarea(attrs{"class":"nombre_clase", "id":"nombre_id", "rows":nº_filas, "cols":nº_columnas})
			}
		labels = {"nombre_campo", "etiqueta_campo"}


En este segundo método podemos sobreescribir los campos del modelo con algo distinto o personalizarlos, en los atributos podemos incluir
clases, como por ejenplo las clases de bootstrap	


Por defecto ,  los campos tienen el atributo "required" y el EmailField valida el formato correcto del email.  Si deseamos que un
campo no sea requerido, en sus argumentos debemos indicar por ejemplo forms.CharField(required = False)

Para introducir fechas : forms.DateField() --> Le corresponde el widget DateInput()
			 
			 forms.DateTimeField() --> El widget es DateTimeInput() , con los atributos auto_now_add = True y auto_now = True
			 			   lo rellenamos con un timestamp de datetime al crearlo y al modificarlo respectivamente

			 Ver widget datepicker en los apuntes de Bootstrap


Para checkbox : models.BooleanField() // forms.CheckboxInput()

		Para comprobar si un checkbox está marcado en el views:

		if "name_checkbox" in request.POST:
			variable = True

Para radio button : Es necesario crear en el models una lista de tuplas , dentro de cada tupla irá esta información

			("nombre_en_bd", "nombre_legible_por_usuario") --> Podemos incluir la lista de tuplas dentro de una variable en MAYUSCULAS

		    models.CharField(choices = CHOICES)
		    
		    forms.CharField( label = "Marque una opción" , widget = forms.RadioSelect(choices = CHOICES) )

		    Para comprobar si un radio button está marcado en el views:

			if "name_radio_button" in request.POST:
			    variable = True


Para select : Es necesario crear en el models una lista de tuplas , dentro de cada tupla irá esta información

			("nombre_en_bd", "nombre_legible_por_usuario") --> Podemos incluir la lista de tuplas dentro de una variable en MAYUSCULAS

		   model.CharField(choices = [("A", "opción A"), ("B", "opción B")]) 

		   forms.ChoiceField(choices = [("A", "opción A"), ("B", "opción B")]) --> El widget por defecto es el select

		   En el views podemos leerlo con request.POST["name_select"]


Para select multiple :  model.ManyToMany(Clase_enlazada)
			forms.MultipleChoiceField(chocies = CHOICES) --> Widget por defecto, select multiple, CHOICES deberá contener las opciones
			que vienen de Clase_enlazada
			
			En este ejemplo vamos a cambiar el widget por defecto por un CheckboxSelectMultiple , que en lugar de pintar un select,
			pinta unos checkbox

		  	test = forms.MulitpleChoiceField(choices=TEST_CHOICES,  widget=forms.CheckboxSelectMultiple(), requrired=False)

		   

Estos son los campos de formularios disponibles :

BooleanField, CharField, ChoiceField, TypedChoiceField, DateField, DateTimeField, DecimalField, DurationField, EmailField, FileField, 
FilePathField, FloatField, ImageField, IntegerField, GenericIPAddressField, MultipleChoiceField, TypedMultipleChoiceField, NullBooleanField, 
RegexField, SlugField, TimeField, URLField, UUIDField, ComboField, MultiValueField, SplitDateTimeField, ModelMultipleChoiceField, ModelChoiceField​​​​.

Los argumentos más comunes que pueden recibir la mayoria de los campos son estos:

required: If True, the field may not be left blank or given a None value. Fields are required by default, so you would set required=False to allow blank values in the form.

label: The label to use when rendering the field in HTML. If label is not specified then Django would create one from the field name by capitalising the first letter and replacing underscores with spaces (e.g. Renewal date).

label_suffix: By default a colon is displayed after the label (e.g. Renewal date:). This argument allows you to specify as different suffix containing other character(s).

initial: The initial value for the field when the form is displayed.

widget: The display widget to use.

help_text (as seen in the example above): Additional text that can be displayed in forms to explain how to use the field.

error_messages: A list of error messages for the field. You can override these with your own messages if needed.

validators: A list of functions that will be called on the field when it is validated.

localize: Enables the localisation of form data input (see link for more information).

disabled: The field is displayed but its value cannot be edited if this is True. The default is False.



Podemos personalizar las validaciones añadiendo métodos a la clase :

Ej.

from django.core.exceptions import ValidationError

def clean_asunto(self, *args, **kwargs)
	asunto = self.cleaned_data["asunto"]
	if asunto = " ":
		raise forms.ValidationError("El campo no puede estar en blanco")
	else:
		return asunto

O podemos añadir validadores directamente en el form invocando funciones que hagan la validación:

Ej

Creamos un módulo llamado validators.py

from django.core.exceptions import ValidationError

def validar_menor_que_cien(value):
    if value >= 100:
        raise ValidationError("El número no es menor que 100")

Y en el forms.py

from . import validators

class MyModel(forms.Form):
    numero_menor_cien = forms.IntegerField(validators=[validar_menor_que_cien]) --> Los validadores se pueden usar también en el models
										    es buena práctica validar en el models y el form


Podemos usar validadores predefinidos, por ejemplo, para usar expresiones regulares :

forms.CharField(validators=[RegexValidator('^(\d){1,2}\:(\d){1,2}$', message="please enter the time in this format: MM:SS")] --> Podemos invocar una variable
																 que contenga la regexp

Para ver todos los validadores predefinidos disponibles , ver Validators en la documentación oficial de Django
    


Por defecto el label es el campo de la clase,  pero se puede personalizar : forms.CharField(label = "etiqueta_formulario")

Si deseamos que por defecto en el campo de formulario se pinte un valor X : forms.CharField(initial = "X")

Podemos añadir widgets y ponerles atributos :  forms.CharField(widget = forms.Textarea(attrs{"class":"nombre_clase", "id":"nombre_id", "rows":nº_filas, "cols":nº_columnas})																					
					       forms.CharField(widget = forms.TextInput(attrs{"placeholder":"indique su email aqui"})

Para ver todo los widgets de los formularios,  ver django documentation forms widgets:

    'Media', 'MediaDefiningClass', 'Widget', 'TextInput', 'NumberInput',
    'EmailInput', 'URLInput', 'PasswordInput', 'HiddenInput',
    'MultipleHiddenInput', 'FileInput', 'ClearableFileInput', 'Textarea',
    'DateInput', 'DateTimeInput', 'TimeInput', 'CheckboxInput', 'Select',
    'NullBooleanSelect', 'SelectMultiple', 'RadioSelect',
    'CheckboxSelectMultiple', 'MultiWidget', 'SplitDateTimeWidget',
    'SplitHiddenDateTimeWidget', 'SelectDateWidget',

Si al crear la instancia no deseamos el formato tabla,  podemos convertir la variable en , por ejemplo , párrafos o listas :
miFormulario = FormularioContacto()

miFormulario = miFormulario.as_p()  // miFormulario.as_ul() --> Convertimos el HTML a párrafo o lista desordenada

Podemos verificar que todas las validaciones son correctas con este método

validacion = miFormulario.is_valid() --> Devuelve True o False


Con este otro método,  leemos los formularios y guardamos su contenido en un diccionario

informacion = miFormulario.cleaned_data  --> Crea {"name_formulario":"valor_formulario", etc....}


En la vista donde guardamos la información del formulario, deberemos hacer lo siguiente:


from nombre_app.forms import FormularioContacto

def guardar_formulario(request):

	if request.method == "POST": --> Esto significa "si el usuario pulsa el submit"

		miFormulario = FormularioContacto(request.POST) 

		if miFormulario.is_valid():

			info = miFormulario.cleaned_data --> Podemos acceder a la información con los métodos de los diccionarios

			insercion_bd = models.Contacto(asunto = info["asunto"] ,  email = info["email"] , mensaje = info["mensaje"])
			insercion_bd.save()
			miFormulario = FormularioContacto() --> Esto resetea el contenido del formulario

	else:
		miFormulario = FormularioContacto() --> Pintamos la tabla de formulario por defecto
		
	context = {"form":miFormulario}

	
	return render(request, "formularios.html", context)


En el HTML :

<html>
<body>

		{% if form.errors %}
		<p style = "color: red;">Revise que este campo sea correcto</p>
		{% endif %}

	<form action = "guardar-formulario" method = "POST"> {% csrf_token %}		
		
		<table>
			
			{{form.as_table}}  --> Tenemos que indicar el formato en que viene del views

		</table>

		<input type = "submit" value = "ENVIAR" />
	</form>

</body>
</html>

Para pintar en el formulario un objeto


Si necesitamos hacer un update (o incluso un delete) de un objeto en la BD,  necesitaremos pintarlo en el formulario,
para ello podemos usar el argumento "instance" de la clase ModelForm

Ej.

def mascota_edit(request, id_mascota):
	mascota = Mascota.objects.get(id = id_mascota)
	if request.method == "GET":
		form = MascotaForm(instance = mascota)
	else:
		form = MascotaForm(request.POST, instance = mascota)
		if form.is_valid():
			form.save()
		return redirect("mascota:mascota_list")
	return render(request, "mascota_form.html", {"form":form})



----------------------------------------------  AJAX  --------------------------------------------------------------------

Con Ajax podemos hacer submit de formularios POST evitando que se recargue la página , lo cual nos permite validar con javascript en
el DOM para ayudar al usuario a rellenarlos correctamente


Ej- 

#clase para los formularios en forms.py ( las regexp están en un módulo a parte)

from django import forms
from . import models
from . import regexp
import re

class FormularioUsuario(forms.ModelForm):
    class Meta:
        model = models.Usuario
        fields = "__all__"
        widgets = {
            "nombre": forms.TextInput(),
            "apellido_1": forms.TextInput(),
            "apellido_2": forms.TextInput(),
            "telefono": forms.NumberInput(),
            "email": forms.EmailInput()
        }

    def clean_nombre(self):
        nombre = self.cleaned_data.get("nombre")
        validacion_nombre = re.compile(regexp.patron_texto)
        if not validacion_nombre:
            raise forms.ValidationError("El formato del nombre no es correcto")
        else:
            return nombre
    def clean_apellido_1(self):
        apellido_1 = self.cleaned_data.get("apellido_1")
        validacion_apellido_1 = re.compile(regexp.patron_texto)
        if not validacion_apellido_1:
            raise forms.ValidationError("El formato del apellido no es correcto")
        else:
            return apellido_1

    def clean_apellido_2(self):
        apellido_2 = self.cleaned_data.get("apellido_2")
        validacion_apellido_2 = re.compile(regexp.patron_texto)
        if not validacion_apellido_2:
            raise forms.ValidationError("El formato del apellido no es correcto")
        else:
            return apellido_2

    def clean_telefono(self):
        telefono = self.cleaned_data.get("telefono")
        validacion_telefono = re.compile(regexp.patron_telefono)
        if not validacion_telefono:
            raise forms.ValidationError("El formato del tf no es correcto")
        else:
            return telefono

    def clean_email(self):
        email = self.cleaned_data.get("email")
        validacion_email = re.compile(regexp.patron_mail)
        if not validacion_email:
            raise forms.ValidationError("El formato del email no es correcto")
        else:
            return  email


#Función jquery a ejecutar en el evento submit


$(document).ready(function(){

    $('#id_form').on('submit', function(event){
        event.preventDefault();
        console.log("form submitted!");
        validacion = validar() --> Creamos una función que valide los campos
        if(validacion){
            create_post();
        }else{
            $("#resultado").html("Revise los campos marcados en rojo")
        }; //end event
    }); //end submit


##Funcion AJAX
$.ajax({
	url: "guardar-formulario",
	type: "POST",
	data: $("#id_form").serialize(), --> Lectura y paso a JSON de los datos del formulario
	success: function(json){
		$("#id_nombre").val("");  --> Reseteo en blanco de los formularios
		$("#id_apellido_1").val("");
		$("#id_apellido_2").val("");
		$("#id_telefono").val("");
		$("#id_email").val("");
		$("#resultado").html("REGISTRO CORRECTO");
		console.log("ajax success OK")
		},

	error: function(xhr,errmsg,err){
		$("#resultado").html("REGISTRO INCORRECTO");
		console.log("ajax error")
		console.log(xhr)
		console.log(errmsg)
		console.log(err)
		}

}); //end ajax

##Funciones de validación CSRF (simplemente hacer copy-paste tal cual al final de nuestro javascript.js)

$(function() {


    // This function gets cookie with a given name
    function getCookie(name) {
        var cookieValue = null;
        if (document.cookie && document.cookie != '') {
            var cookies = document.cookie.split(';');
            for (var i = 0; i < cookies.length; i++) {
                var cookie = jQuery.trim(cookies[i]);
                // Does this cookie string begin with the name we want?
                if (cookie.substring(0, name.length + 1) == (name + '=')) {
                    cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                    break;
                }
            }
        }
        return cookieValue;
    }
    var csrftoken = getCookie('csrftoken');

    /*
    The functions below will create a header with csrftoken
    */

    function csrfSafeMethod(method) {
        // these HTTP methods do not require CSRF protection
        return (/^(GET|HEAD|OPTIONS|TRACE)$/.test(method));
    }
    function sameOrigin(url) {
        // test that a given url is a same-origin URL
        // url could be relative or scheme relative or absolute
        var host = document.location.host; // host + port
        var protocol = document.location.protocol;
        var sr_origin = '//' + host;
        var origin = protocol + sr_origin;
        // Allow absolute or scheme relative URLs to same origin
        return (url == origin || url.slice(0, origin.length + 1) == origin + '/') ||
            (url == sr_origin || url.slice(0, sr_origin.length + 1) == sr_origin + '/') ||
            // or any other URL that isn't scheme relative or absolute i.e relative.
            !(/^(\/\/|http:|https:).*/.test(url));
    }

    $.ajaxSetup({
        beforeSend: function(xhr, settings) {
            if (!csrfSafeMethod(settings.type) && sameOrigin(settings.url)) {
                // Send the token to same-origin, relative URLs only.
                // Send the token only if the method warrants CSRF protection
                // Using the CSRFToken value acquired earlier
                xhr.setRequestHeader("X-CSRFToken", csrftoken);
            }
        }
    });

});


##Códgio en el views para tratar la peticón


def guardar_formulario(request):
    context = {}
    if request.method == "POST":
        formulario = forms.FormularioUsuario(request.POST)
        if formulario.is_valid():
            usuario = models.Usuario(nombre = formulario.clean_nombre(), --> metodo clean creado en el forms
                                     apellido_1 = formulario.clean_apellido_1(),
                                     apellido_2 = formulario.clean_apellido_2(),
                                     telefono = formulario.clean_telefono(),
                                     email = formulario.clean_email()
                                     )
            usuario.save()
            formulario = forms.FormularioUsuario()

            context = {
                "formulario":formulario
            }
            return render(request, "index.html", context)
    else:
        context = {
            "formulario":formulario,
        }


########################################  REDIRECCION DE RUTAS  #########################################################

from django.shortcuts import redirect

return redirect("/ruta	_raiz/nombre_ruta")

NOTA:
return render --> Usado para renderizar una determinada template con su context

return redirect --> Para llamar a una determinada ruta al ejecutar una vista

return nombre_vista(request) --> Para llamar a otra vista tras finalizar la ejecución de una vista


######################################## MODULO DE USUARIOS  #####################################################################

Django incorpora un módulo de gestión de usuarios,  la forma más normal es disponer de una clase User en el models y crear un
superusuario para el portal de administración con python manage.py createsuperuser (nos pide el usuario y contraseña administrador),
con dicho superusuario podemos crear y eliminar usuarios en el portal de administración

Podemos cambiar la password de un usuario mediante el comando python manage.py changepassword nombre_usuario


Ver https://docs.djangoproject.com/en/3.0/topics/auth/default/#django.contrib.auth.views.LoginView



####################################  ELEMENTOS ESTATICOS  ##############################################################

Para cargar en Django elementos estáticos,  debemos guardarlos en una carpeta llamada static , y en el template HTML debemos
indicar lo siguiente :

Arriba del todo del template 

{% load static %}

Para el CSS

<link rel="stylesheet" href="{% static 'estilos.css' %}"/>

Para el Bootstrap

<link rel="stylesheet" href="{% static 'bootstrap/css/bootstrap.min.css' %}"/>

Para el Javascript

<script language="javascript" src="{% static 'javascript.js' %}"></script>

Para las imagenes

<img src = "{% static 'imagen.jpg' %}" />

Y asi cualquier otro elemento estático que deseemos añadir

############################  BUSCADOR (FILTRADO) Y PAGINACION  #################################################################

En el HTML

<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Portal de adopción de perros</title>
    {% load static %}
    <link rel="stylesheet" href="{% static 'estilos.css' %}"/>
    
    <script language="javascript" src = "{% static 'javascript.js' %}"></script>

</head>
<body>    
    {% static 'fotos' as ruta_imagenes %}
    <header>
    <h1>PORTAL DE ANUNCIOS PARA LA ADOPCION DE PERROS</h1>
    </header>
    <nav> 
    <ul>
    <li><a href ="registro-usuario">REGISTRO EN EL PORTAL</a></li>
    <li><a href = "inicio-sesion-usuario">INICIO DE SESION</a></li>
    <li><a href = "/admin" >ACCESO ADMINISTRADORES</a></li>     
    </ul>          
    <form action ="/anuncios" method="GET" id ="form_buscador">
    <label>BUSCA TU PERRO&nbsp;</label>
    <input type = "text" name = "criterio" value = "{{valor_en_buscador}}"  placeholder="filtra por criterio..." id = "buscador"/>
    <input type ="submit" value = "BUSCAR" id ="submit"/> 
    </form>
    <br/>
    <span id = "anuncios_totales">&nbsp;Anuncios totales : {{anuncios_totales}}</span>
    <br/>
    {% if filtrado == True %}
        <div id = "btn_limpiar">    
        <a href = "/anuncios" id = "limpiar" ><button>{{limpiar}}</button></a>    
        </div>
    {% endif %}
    <br/>
    </nav>
    <main>

        <table>
            <tr class = "cabecera_anuncios">
                <th>Nombre</th>
                <th>Raza</th>
                <th>Edad</th>
                <th>Color de pelo</th>
                <th>Defectos fisicos</th>
                <th>Vacunado</th>
                <th>Categoria</th>
                <th>Foto</th>     
                <th>Tf Contacto</th>
            </tr>    
            
            {% for perro in anuncios %}
                <tr class = "linea">
                    <td>{{ perro.nombre}}</td>
                    <td>{{ perro.raza}}</td>
                    <td>{{ perro.edad}}</td>
                    <td>{{ perro.color_pelo}}</td>
                    <td>
                        {% if perro.defectos_fisicos == True %}
                        SI
                        {% elif perro.defectos_fisicos == False %}
                        NO                        
                        {% endif %}
                    </td>                    
                    <td>
                        {% if perro.vacunado == True %}
                        SI
                        {% elif perro.vacunado == False %}
                        NO                        
                        {% endif %}
                    </td>
                    <td>{{perro.categoria.categoria}}</td>
                    <td id = "celda_foto"><img src = "{{ruta_imagenes}}/{{perro.id}}.jpg?um={{perro.ultima_modificacion}}" alt = "Foto no disponible" id = "foto_perro" /></td>  
                    <td>{{perro.usuario.telefono}}</td>
                </tr>
                {% endfor %}      
        
    </table>
    </main>
    <footer>        

        {% if filtrado == False %}
    
            {% if siguiente < anuncios_totales and siguiente == paginacion %}
                <a href="/anuncios?comienzo={{siguiente}}" class = "paginacion" >SIGUIENTE >>>&nbsp;&nbsp;&nbsp;</a>
           
            {% elif siguiente < anuncios_totales and siguiente > paginacion %}
                <a href="/anuncios?comienzo={{anterior}}" id = "paginacion2">&nbsp;&nbsp;&nbsp;<<< ANTERIOR</a>
                <a href="/anuncios?comienzo={{siguiente}}" class = "paginacion" >SIGUIENTE >>>&nbsp;&nbsp;&nbsp;</a>

            {% elif anuncios_totales <= paginacion %}
                <span>&nbsp;&nbsp;&nbsp;NO HAY MAS ANUNCIOS</span>

            {% else %}
                <a href="/anuncios?comienzo={{anterior}}" class = "paginacion"><<< ANTERIOR&nbsp;&nbsp;&nbsp;</a>

            {% endif %}

        {% elif filtrado == True %}

            {% if siguiente < anuncios_totales and siguiente == paginacion %}
                <a href="/anuncios/?criterio={{valor_buscado}}&comienzo={{siguiente}}" class = "paginacion" >SIGUIENTE >>>&nbsp;&nbsp;&nbsp;</a>

            {% elif siguiente < anuncios_totales and siguiente > paginacion %}   
                <a href="/anuncios/?criterio={{valor_buscado}}&comienzo={{anterior}}" id = "paginacion2">&nbsp;&nbsp;&nbsp;<<< ANTERIOR</a>
                <a href="/anuncios/?criterio={{valor_buscado}}&comienzo={{siguiente}}" class = "paginacion" >SIGUIENTE >>>&nbsp;&nbsp;&nbsp;</a> 

            {% elif anuncios_totales <= paginacion %}
                <span>&nbsp;&nbsp;&nbsp;NO HAY MAS ANUNCIOS</span>

            {% else %}
                <a href="/anuncios/?criterio={{valor_buscado}}&comienzo={{anterior}}" class = "paginacion"><<< ANTERIOR&nbsp;&nbsp;&nbsp;</a>

            {% endif %}

        {% endif %}
        
    </footer> 

</body>
</html>

En el VIEWS

def inicio(request):
    anuncios = models.Perros.objects.all().order_by("-ultima_modificacion" ,"-id").prefetch_related("categoria", "usuario")

    criterio = ""
f    valor_en_buscador = ""
    filtrado = False

    if "criterio" in request.GET:
        criterio = request.GET["criterio"]
        filtrado = True
        if len(anuncios.filter(nombre__contains=criterio)) != 0:
            anuncios = anuncios.filter(nombre__contains=criterio)
        elif len(anuncios.filter(raza__contains=criterio)) != 0:
            anuncios = anuncios.filter(raza__contains=criterio)
        elif len(anuncios.filter(edad__contains=criterio)) != 0:
            anuncios = anuncios.filter(edad__contains=criterio)
        elif len(anuncios.filter(color_pelo__contains=criterio)) != 0:
            anuncios = anuncios.filter(color_pelo__contains=criterio)
        elif len(anuncios.filter(defectos_fisicos__contains=criterio)) != 0:
            anuncios = anuncios.filter(defectos_fisicos__contains=criterio)
        elif len(anuncios.filter(vacunado__contains=criterio)) != 0:
            anuncios = anuncios.filter(vacunado__contains=criterio)
        else:
            categorias = models.Categorias.objects.filter(categoria__contains=criterio)
            anuncios_finales = []

            for c in categorias:
                anuncios_finales.extend(anuncios.filter(categoria=c))
            anuncios = anuncios_finales

    valor_en_buscador = criterio
    valor_buscado = criterio
    anuncios_totales = len(anuncios)
    comienzo = 0

    if "comienzo" in request.GET:
        comienzo = int(request.GET["comienzo"])

    paginacion = 5
    paginado = anuncios[comienzo:comienzo + paginacion]
    longitud_paginado = len(paginado)
    siguiente = comienzo + paginacion
    anterior = comienzo - paginacion

    context = {
        "anuncios" : paginado, 
        "anuncios_totales" : anuncios_totales, 
        "siguiente" : siguiente,
        "anterior": anterior,
        "valor_en_buscador": valor_en_buscador,
        "limpiar": "LIMPIAR BUSQUEDA",
        "filtrado": filtrado,
        "valor_buscado" : valor_buscado,
        "paginacion" : paginacion

        }    
    return render(request, "index.html", context)


############################################  COOKIES  ################################################################

Las cookies son archivos con información del usuario y su actividad que el servidor guarda en los navegadores, cada vez
que el usuario vuelva a visitar un site , su navegador enviará la cookie junto con la petición GET/HTTP

LEER COOKIES

Cada objeto request contiene a su vez un objeto COOKIES que se comporta como un diccionario,  podemos usar dicho objeto
para leer cualquier cookie que el navegador del usuario haya enviado a la vista de Django

Ej

def show_color(request):
    if "favorite_color" in request.COOKIES:
        return HttpResponse("Your favorite color is %s" % request.COOKIES["favorite_color"])
    else:
        return HttpResponse("You don't have a favorite color.")

ENVIAR COOKIES

Debemos usar el método set_cookie() en un objeto de tipo HttpResponse. He aquí un ejemplo que define la cookie favorite_color 
utilizando el valor que se le pasa como parámetro GET:

def set_color(request):
    if "favorite_color" in request.GET:

        # Create an HttpResponse object...
        response = HttpResponse("Your favorite color is now %s" % request.GET["favorite_color"])

        # ... and set a cookie on the response
        response.set_cookie("favorite_color", request.GET["favorite_color"])

        return response

    else:
        return HttpResponse("You didn't give a favorite color.")

Hay una serie de parámetros opcionales que puedes pasar a response.set_cookie() y que te permiten controlar determinadas 
características de la cookie:

max_age: el tiempo (en segundos) que la cookie debe permanecer activa. Si este parámetro es la cookie, desaparecerá 
	 automáticamente cuando se cierre el navegador. (valor por defecto: None)

expires: la fecha y hora en que la cookie debe expirar. Debe estar en el formato "Wdy, DD-Mth-YY HH:MM:SS GMT". 
	 Si se utiliza este parámetro, su valor tiene preferencia sobre el definido mediante max_age. (valor por defecto: None)

path: la ruta o path para la cual es válida la cookie. Los navegadores solo reenviarán la cookie a las páginas que estén en dicha 
      ruta. Esto impide que se envíe esta cookie a otras secciones de la web. Es especialmente útil si no se tiene el control del 
      nivel superior de directorios del servidor web. (valor por defecto: "/")

domain: el dominio para el cual es válida la cookie. Se puede usar este parámetro para definir una cookie que sea apta para varios 
	dominios. Por ejemplo, definiendo domain=".example.com" la cookie será enviada a los dominios www.example.com, www2.example.com 
	y aun.otro.subdominio.example.com. Si a este parámetro no se le asigna ningún valor, la cookie solo será enviada al dominio que 
	la definió. (valor por defecto: "/")

secure: si este valor se define como True, se le indica al navegador que sólo retorne esta cookie a las páginas que se accedan de forma 
	segura (protocolo HTTPS en vez de HTTP). (valor por defecto: False)

Como no podemos saber si un usuario tiene habilitadas las cookies, lo cual puede ser un problema para enviarle la cookie
de sesión de usuario,  Django dispone de un mecanismo para enviar una cookie de prueba y luego comprobar si esta ha funcionado:


def login(request):

    # If we submitted the form...
    if request.method == 'POST':

        # Check that the test cookie worked (we set it below):
        if request.session.test_cookie_worked():

            # The test cookie worked, so delete it.
            request.session.delete_test_cookie()

            # In practice, we'd need some logic to check username/password
            # here, but since this is an example...
            return HttpResponse("You're logged in.")

        # The test cookie failed, so display an error message. If this
        # was a real site we'd want to display a friendlier message.
        else:
            return HttpResponse("Please enable cookies and try again.")

    # If we didn't post, send the test cookie along with the login form.
    request.session.set_test_cookie()
    return render('login_form.html')


#######################################  SESIONES DE USUARIO  ####################################################################

AUTENTICACION DE USUARIOS

Usamos la propiedad session del objeto request, que funciona como un diccionario y envia una cookie con un hash pseudo-aleatorio de 32 
caracteres, que es el valor que se almacena en la cookie

Tomaos el usuario y la contraseña :

usuario_insertado = request.POST["usuario"]
clave_insertada = request.POST["clave"]

Tendremos una clase Usuarios para la tabla de usuarios con el Id de usuario, el nombre de usuario y la clave

Buscamos en dicha tabla lo que leemos en los formularios:

resultado = models.Usuarios.objects.filter(usuario == usuario_insertado, clave == clave_insertada)

La lista de objetos que se crea puede localizar una coincidencia o ninguna en la tabla de usuarios:

if len(resultado == 1):
    usuario = resultado[0] --> Tomamos el objeto usuario de la lista de objetos traida de la BBDD
    request.session["id_usuario"] = usuario.id  --> Ponemos el "sello" de la sesión

Y finalmente, para cerrar la sesión :

request.session.clear()

En la documentación existen otras opciones para la gestión de sesiones mediante configuraciones en el settings.py:

SESSION_COOKIE_SECURE: indica si se debe usar una cookie segura para la cookie de sesión. Si el valor es True, la cookie 
		       se marcará como segura, lo que significa que sólo se podrá utilizar mediante el protocolo HTTPS. 
		       (Valor por defecto: False).

SESSION_COOKIE_AGE:  Tiempo en segundos que tarda en expirar la cookie de sesión, por defecto 1.209.600 seg, o sea, 2 semanas

SESSION_EXPIRE_AT_BROWSER_CLOSE: Por defecto su valor es False, esto quiere decir que las session cookies serán almacenadas
				 en el navegador del usuario durante el tiempo indicado en SESSION_COOKIE_AGE. Esto es util
				 si no queremos que nuestros usuarios tengan que logarse cada vez que abran el navegador.
				 Si establecemos el valor a True, la cookie de sesión expira al cerrar el navegador y cada
				 vez que el usuario lo abra, tendrá que logarse de nuevo



############################  VISTAS BASADAS EN CLASES ( CLASS-BASED-VIEWS)  ##########################################

Django incorpora una serie de clases predefinidas que podemos usar, heredar e incluso modificar en nuestro views usando la funcion
as_view() ,  dicha función puede recibir argumentos que sobreescribiran las propiedades de la la clase

Existen dos formas de usar estas clases :

Primera :

from django.urls import path
from django.views.generic import TemplateView

urlpatterns = [
    path('about/', TemplateView.as_view(template_name="about.html")),
]

En este caso indicamos a la función as_view() directamente la propiedad que deseamos sobreescribir

Segunda :

En esta segunda forma creamos subclases heredando de la clase padre predefinida y sobreescribiendo la propiedad en ellas:

from django.views.generic import TemplateView

class AboutView(TemplateView):
    template_name = "about.html"

# urls.py
from django.urls import path
from some_app.views import AboutView

urlpatterns = [
    path('about/', AboutView.as_view()),
]

CLASES ABSTRACTAS

En su class Meta indicamos abstract = True , con esto sus clases hijas heredan directamente sus propiedades, y ya no es
necesario vover a escribir esas propiedades en las hijas , en este ejemplo la clase Estudiante hereda nombre y edad:


class InfoComun(models.Model):
    nombre = models.CharField(max_length=100)
    edad = models.PositiveIntegerField()

    class Meta:
        abstract = True

class Estudiante(InfoComun):
    grupo = models.CharField(max_length=5)


Las clases hijas , si no definen parámetros meta,  heredan de la abstracta, pero pueden extender los parámetros meta
de esta úlitma, como en este ejemplo

class InfoComun(models.Model):
    ...
    class Meta:
        abstract = True
        ordering = ['nombre']

class Estudiante(InfoComun):
    ...
    class Meta(InfoComun.Meta):
        db_table = 'estudiantes_info'


------------------------------------------  CLASS-BASED-VIEWS CRUD  ----------------------------------------------------------


SELECT - ListView (listados):



Clase predefinida para pintar listados , podemos heredar de ella para crear nuestros propios listados

En el views.py

from django.views.generic import ListView
from . import models

class Mi_clase_listar(ListView):

	model = models.Mi_modelo
	template_name = "nombre_app/mi_listado.html"
	paginate_by = numero_entero --> Resultados por página

En el urls.py  --> IMPORTANTE, el context no trae un diccionario, sino un object_list

from . import views

urlpatterns = [path("ruta-listado", views.Mi_clase_listar.as_view() , name = "mi_lista")]

En template

Aqui debemos tener en cuenta que el context ya no trae un diccionario clave:valor,  lo que viene es un object_list

{% if object_list %}
{% for mi_objeto in object_list %}
	mi_objeto.propiedad1
	mi_objeto.propiedad2
	etc....
{% endfor %}

A efectos de hacer más comprensible el object_lista ,  Django nos permite cambiarle el nombre al crear la clase en el view
de esta manera:

context_object_name = 'mis_autores_favoritos'  --> En el template el bucle for podría ser por ejemplo for autor in mis_autores_favoritos

INSERT - CreateView


En el views.py

from django.views.generic import CreateView
from . import forms
from . import models
from django.core.urlresolvers import reverse_lazy

class Mi_clase_crear(CreateView):
	
	model = models.Mi_modelo
	form_class = forms.Mi_formularioForm
	template_name = "nombre_app/mi_form.html"
	success_url = reverse_lazy("mi_app:mi_lista") --> Esta linea redirige al url con name = mi_lista de mi_app


En el urls.py

from . import views

urlpatterns = [path("mi-formulario", views.Mi_clase_crear.as_view(), name = "mi_insert")]


UPDATE- UpdateView

En el views.py

from django.views.generic import UpdateView
from django.core.urlresolvers import reverse_lazy
from . import models
from . import forms

class Mi_clase_update(UpdateView):

	model = models.Mi_modelo
	form_class = forms.Mi_formularioForm
	template_name = "nombre_app/mi_form.html"
	success_url = reverse_lazy("mi_app:mi_lista") 

En el urls.py

from . import views

urlpatterns = [path("mi-upate/<int:pk>", views.Mi_clas_update.as_view(), name = "mi_update")] --> importante pasar el parámetro pk (primary key)

En el template

Recordar que no viene un diccionario, sino un object o un object_list

Para pintar un objeto en el template sería con object.propiedad1, object.propiedad.2 , etc....


DELETE - DeleteView

En el views.py

from django.views.generic import DeleteView
from django.core.urlresolvers import reverse_lazy
from . import models
from . import forms

class Mi_clase_detele(DeleteView):

	model = models.Mi_modelo
	form_class = forms.Mi_formularioForm
	template_name = "nombre_app/mi_form.html"
	success_url = reverse_lazy("mi_app:mi_lista") 


En el urls.py


from . import views

urlpatterns = [path("mi-upate/<int:pk>", views.Mi_clas_delete.as_view(), name = "mi_delete")] --> importante pasar el parámetro pk (primary key)


En el template

Recordar que no viene un diccionario, sino un object o un object_list

Para pintar un objeto en el template sería con object.propiedad1, object.propiedad.2 , etc....


SOBREESCRITURA DE LAS CLASES CRUD PREDEFINIDAS 

Podemos sobreescribir las propiedades y métodos de las clases predefinidas, esto es muy util cuando necesitamos renderizar en una misma
web por ejemplo dos formularios que vienen de modelos distintos

Ej Persona que solicita adoptar una o más mascotas

En el models.py

class Persona(models.Model):
	nombre = models.CharField(max_length = 50)
	apellidos = models.CharField(max_length = 100)
	edad = models.IntegerField()
	telefono = models.CharField(max_length = 9)
	email = models.EmailField()
	domicilio = models.TextField()

class Solicitud(models.Model):
	persona = models.ForeignKey(Persona, null = True, blank = True)
	numero_mascotas = models.IntegerField()
	razones = models.TextField()

En el forms.py

Damos creados los formularios PersonaForm y SolicitudForm con meta clases que contienen los model, fields, label y widgets , en el
segundo no hace falta definir el field persona , ya que ese dato se relaciona con el primero


En el views.py
 

class SolicitudList(ListView):
	model = models.Solicitud
	template_name = "nombre_app/solicitud_list.html"

class SolicitudCreate(CreateView):
	model = models.Solicitud
	template_name = "nombre_app/solicitud_form.html"
	form_class = SolicitudForm --> Primer formulario
	second_form_class = PersonaForm --> Segundo formulario
	success_url = reverse_lazy("adopcion:listado") --> app adopcion,  url con =  name = listado

	def get_context_data(self, **kwargs): --> Para sumar los dos formularios al mismo context, sobreescribimos el método get_context_data()

		context = super(SolicitudCreate, self).get_context_data(**kwargs)
		if "form" not in context:
			context["form"] = self.form_class(self.request.GET)
		if "form2" not in context:
			context["form2"] = self.second_form_class(self.request.GET)
	
	def post(self, request, *args, **kwargs):

		self.object = self.get_object --> Accedemos al objeto POST del formulario
		form = self.form_class(request.POST)
		form2 = self.second_form_class(request.POST)
		if form.is_valid() and form2.is_valid():		
			solicitud = form.save(commit = False) --> Evitamos el commit hasta no guardar el segundo formulario
			solicitud.persona = form2.save() --> Creamos la relación entre formularios
			solicitud.save()
			return redirect(self.get_success_url)
		else:
			return render(request, "solicitud_form.html",  self.get_context_data(form = form, form2 = form2)


En el template.html

	Para pintar por ejemplo las cajas solicitando el nombre y los apellidos

	<label for = {{form2.nombre.nombre}}> {{form2.nombre.label}} </label> --> Accedemos a la propiedad label definida en forms.py
	{{form2.nombre}}

	<label for = {{form2.nombre.apellido}}> {{form2.apellidos.label}} </label> --> Accedemos a la propiedad label definida en forms.py
	{{form2.apellidosg}}


----------------------------------------  LISTADO DE GENERIC VIEWS  ---------------------------------------------

View --> Clase maestra, todas las class-based views heredan de ella
Metodos:
as_view()
setup()
dispatch()
http_method_not_allowed()
options()

TemplateView --> Renderiza una plantilla dada, con un contexto conteniendo parámetros capturados en la URL
Métodos:
setup()
dispatch()
http_method_not_allowed()
get_context_data()

RedirectView --> Redirige a otra URL
Métodos:
setup()
dispatch()
http_method_not_allowed()
get_redirect_url()


DetailView --> Vista genérica de datalles de objetos
Métodos:
setup()
dispatch()
http_method_not_allowed()
get_template_names()
get_slug_field()
get_queryset()
get_object()
get_context_object_name()
get_context_data()
get()
render_to_response()

ListView --> Lista de objetos
Métodos:
setup()
dispatch()
http_method_not_allowed()
get_template_names()
get_queryset()
get_context_object_name()
get_context_data()
get()
render_to_response()

FormView --> Muestra un formulario, ante errores de validación , vuelve a mostrar el formulario con dichos erroes. En caso de éxito,
	     redirige a una nueva URL

CreateView --> Muestra un formulario para crear un objeto, muestra errores de validación y guarda el objeto
atributos : object (el objeto que estamos creando) , mientras usamos esta clase podemos accederlo con self.object

UpdateView --> Mustra un formulario para editar un objeto existente ,  muestra errores de validación y guarda los cambios
atributos : object (el objeto que estamos modificando) , mientras usamos esta clase podemos accederlo con self.object

DeleteView --> Muestra una página de confirmación y elimina un objeto


A parte de estas, existen unas Generic Date Views, una serie de Mixins para herencia múltiple (clases que contienen métodos que pueden usar otras clases)

Para más información sobre vistas basdas en clases ver https://docs.djangoproject.com/en/3.0/topics/class-based-views/

Para más información sobre las clases internas de Django ( sus métodos y atributos) ver https://docs.djangoproject.com/en/3.0/ref/class-based-views/flattened-index/

------------------------------------  USER MODEL CLASS  -----------------------------------------------------------------------

Django dispone de una clase models.User ,  los objetos User tienen las siguientes propiedades:

username --> Requerido, max 150 caracteres, admite _ @ + - (customizar a 191 si usamos MySQL con codificación utf8mb4)

first_name --> Opcional (blank = True), max 30 caracteres

last_name --> Opcional (blank = True), max 150 caracteres

email --> Opcional (blanck = True)

password --> Requerido, pueden ser de cualquier longitud y cualquier caracter, Django las guarda encriptadas, en el
	     settings.py se requiere configurar una lista de algortimos llamada PASSWORD_HASHERS
	     También hay una lista de AUTH_PASSWORD_VALIDATORS con unos requerimientos mínimos de seguirdad a la hora
	     de que un usuario establezca su contraseña, con help_text de ayuda, es customizable . La longitud por defecto
	     es de 8 caracteres
	     ver documentación en https://docs.djangoproject.com/en/3.0/topics/auth/passwords/

Existen más propiedades, ver https://docs.djangoproject.com/en/3.0/ref/contrib/auth/


------------------------------------  AUTENTICACION (class LoginView)  -------------------------------------------

Podemos usar para el login de usuarios la clase LoginView , o heredar de ella para customizar nuestra propia clase


Ver https://docs.djangoproject.com/en/3.0/topics/auth/default/#django.contrib.auth.views.LoginView



############################ SUBIR PROYECTOS DJANGO A PYTHON ANYWHERE  ###############################################

Estructura de directorios por defecto en Python Anywhere

/mysite
	/mysite
		settings.py
		urls.py
		wgsi.py
	/my_app
		/migrations
		/templates
		admin.oy
		apps.py
		models.py
		tests.py
		urls.py
		utilities.py
		views.py
	/static
		/admin
			/css
			/fonts
			/img
			/js
	/media


	manage.py

Al crear un poryecto Django en PythonAnywhere , se crean automáticamente los archivos settins.py y urls.py del proyecto,
con lo cual nosotros sólo debemos subir el contenido de la carpeta donde se encuentre nuestra APP, creando el directorio
con el nombre de dicha APP y las subcarpetas static, templates......

Una vez subidos los archivos, en settings.py debemos añadir a la ilsta INSTALLED_APPS nuestra APP y crear la BD de MySQL,
añadiendola a la lista DATABASES de settings.py , también hay que poner el DEBUG a False, ya que en el debugging sólo se
puede hacer en local

En urls.py de la raiz del proyecto añadiremos con include la ruta de la raiz que vayamos a usar

Finalmente, en la consola BASH ejecutamos estas sentencias ( en este caso con Python 3.8)

python3.8 manage.py makemigrations nombre_app

python3.8 manage.py migrate

python3.8 manage.py collectstatic ( sin esto no reconoce el contenido de static)

Con esto nuestro proyecto Django ya está listo para trabajar con él



############################  IMAGENES Y ARCHIVOS  ##################################################################

Este código permite guardar una imagen o cualquier otra clase de archivo, como un PDF

En el HTML :

Para subir imagenes

<form action = "guardar-nuevo-anuncio" method="post" enctype="multipart/form-data">

	 <input type="file" name="foto"/>

Para mostrar imagenes, en la parte de arriba del <body> incluimos esto 

{% load static %}
{% static 'nombre_carpeta_imagenes' as ruta_imagenes %}

Y para que aparezca la imagen

<img src="{{ruta_imagenes}}/{{elemento.id}}.jpg" />

En el VIEWS

from django.core.files.storage import default_storage
from django.core.files.base import ContentFile

#Comprobar si hay una imagen o archivo para cargar:

if "imagen" in request.FILES:
    imagen = request.FILES["imagen"]
    código......

#Guardamos una imagen nombrandola con el id en BBDD del registro al que hace referencia en el directorio static

    id_anuncio = anuncio.id --> Viene de un objeto obtenido de la BBDD
    ruta = "anuncios/static/imagenes/" + str(id_anuncio) + ".jpg"
    f = request.FILES["foto"]
    default_storage.save(ruta, ContentFile(f.read()))   

#Sustituimos la imange actual por otra nueva (hay que borrar previamente la anterior):

    id_anuncio = anuncio.id --> Viene de un objeto obtenido de la BBDD
    ruta = "anuncios/static/imagenes/" + str(id_anuncio) + ".jpg"
    default.storage.delete(ruta)
    f = request.FILES["foto"]
    default_storage.save(ruta, ContentFile(f.read()))   

#Refresco automático de imagenes:

from django.utils import timezone

En el archivo settings.py, modificamos el TIME ZONE :

TIME_ZONE = 'Europe/Madrid'

En el models.py es necesario disponer de un campo en una tabla que almacene una fecha de última modificación

ultima_modificacion = models.DateTimeField("fecha ultima modificacion") 

En el views.py añadimos el código para guardar en una propiedad el timestamp (Ej. registro anuncio)

anuncio.ultima_modificacion = timezone.now()

En el HTML añadimos un parámetro a la ruta de la imagen 

Ej. mostrando las propiedades de un anuncio ( um sería ultima modificacion)

{% load static %}
{% static 'imagenes' as ruta_imagenes %}

	{% for anuncio in anuncios %}
		<img src="{{ruta_imagenes}}/{{a.id}}.jpg?um={{a.ultima_modificacion}}" />


############################  PANEL DE ADMINISTRACION  ##############################################################

La web de administracion que incorpora Django está en la ruta /admin que aparece en el archivo urls.py de la raiz del
proyecto

Para visualizar las tablas de la BBDD en este portal, hay que incluir las clases con las que las hemos creado en el archivo
admin.py de nuestra APP de esta manera:

from . import models

admin.site.register(models.nombre_clase)

IMPORTANTE -  En el Panel de administracion se añade una s al final del nombre de la clase , por lo que habria que evitar
crear modelos con nombres en plural

También es conveniente añadir las clases un método __str__(self) en el cual definamos un string que muestre la información
contenida en las clases que queramos que aparezca en el listado del panel de administración, de lo contrario aparece un
listado con números de objetos:

Ej __str__(self):
       return "El usuario se llama {} {} {}".format(self.nombre, self.apellido1, self.apellido2)

Por último , hay que crear el superusuario administrador del portal, que a su vez podrá crear otros administradores:

python manage.py createsuperuser


En el panel aparecen los campos de las tablas creadas en models.py nombrados con la priemra letra en mayuscula y cambiando
los guiones bajos por un espacio.  Si por alguna razón necesitamos que se pinte en el panel el nombre de algún campo con
otro nombre disinto, basta con añadir esto en el propiedad de la clase:

nombre = models.CharField(max_length = 20, verbose_name = "Nombre de Usuario")

Podemos personalizar los campos de los modelos que se muestran en el panel, para ello en admin.py hay que crear una clase
que , heredando de admin.ModelAdmin, indique los campos que serán visibles del modelo en cuestión;


	class nombre_claseAdmin(admin.ModelAdmin):
		list_display = ("nombre_campo1", "nombre_campo2"....)
		search_fields = ("nombre_campo1", "nombre_campo2"....) --> Estos son campos por los cuales buscar en el panel
		list_filter = ("nombre_campo1", "nombre_campo2"....) --> Estos son campos por los cuales filtrar en el panel
		date_hierarchy = ("campo_fecha",) --> Esto añade menús de selección de fechas en la parte superior del panel

Y actualizar el registro:

admin.site.register(nombre_clase, nombre_claseAdmin)

De esta manera en el panel se muestra sólo lo añadido en la clase que enmascara a la real, y además se añade un buscador en el
panel y un filtro ( si usamos un campo DateField, Django añade varios filtros por dias, meses, años...)


##############################  OBTENER IP DE USUARIO Y GEOLOCALIZACION  ###################################################

Con este código podemos ver toda la información de usuario que se almacena en los datos META:

    texto = "info del usuario:<br/>"
    elementos_en_META =  str(request.META.keys())
    texto += elementos_en_META
    return HttpResponse(texto)

La funcionalidad de obtener IP no suele estar en los archivos views.py , suelen estar en uno a parte llamado utils.py:


def obtener_ip(request):
    x_forwarded_for = request.META.get('HTTP_X_FORWARDED_FOR')
    if x_forwarded_for:
        return x_forwarded_for.split(",")[0]
    return request.META.get('REMOTE_ADDR')

En el models.py debemos añadir un campo con la ip del usuario :

Ej 

ip = models.CharField(max_length = 200)


Y luego en el views.py hacemos uso de esta función:

Ej.  Captura de la IP al guardar un anuncio

from . import utils

anuncio.ip = utils.obtener_ip(request)


Para geolocalizar la IP,  es necesario hacer uso de un servicio REST externo, como por ej. https://www.infosniper.net


######################################  CODIGO DE TESTEO  ###########################################################

En test.py podemos definir funciones que hagan un test a nuestro código Django para ver si el funcionamiento es correcto


Con esta instrucción, ejecutamos todas las funciones que haya definidas en test.py

python manage.py test

Ej.  Testeamos que el registro de un usuario en un portal de anuncios es correco :

from . import models

class TestRegistroAnuncio(TestCase):
    def setUp(self):        
        models.Usuario.objects.create(nombre="pruebas",email="rueba@gmail.com", clave="123")
        
    def test_registro_usuario(self):
        usuario = models.Usuario.objects.get(email = "prueba@gmail.com")
        self.assertEqual(usuario.email, "prueba@gmail.com")

Todo lo que sea creado en la BD en el método SetUp(self) ,  se borrará automáticamente al finalizar el test

Respecto de self.assert ,  tiene diferentes valores ( en este caso es Equal) . Ver documentacion https://docs.djangoproject.com/en/3.0/topics/testing/tools/


####################################  ENVIO DE EMAIL  ##############################################################


En settings.py:

EMAIL_BACKEND = "django.core.mail.backends.smtp.EmailBackend"
EMAIL_HOST = "smtp.gmail.com"
EMAIL_USE_TLS = True
EMAIL_PORT = 587
EMAIL_HOST_USER = "yourusername@gmail.com"
EMAIL_HOST_PASSWORD = 'yourpassword'

En Views

from django.core.mail import send_mail

send_mail(
    'Subject here',
    'Here is the message.',
    'from@example.com',
    ['to@example.com'],
    fail_silently=False,
)

Si necesitamos que nuestra aplicación nos envie un correo desde un formulario de contacto , en el VIEWS tenemos que indicar:

Ej. tenemos un formulario con los campos ASUNTO, EMAIL_USUARIO, MENSAJE

from django.core.mail import send_mail
from django.conf import settings

subject = request.POST["asunto"]

message = request.POST["mensaje"] + " " + request.POST["email_usuario"]  --> Esto es para que veamos el email de quien nos escribe

email_from = settings.EMAIL_HOST_USER

recipient_list = ["nuestro_email@gmail.com"]

send_mail(subject, message, email_from, recipient_list)


Y si necesitamos enviar el correo en formato HTML, podemos usar la función render_to_string y la funcion EmailMessage

from django.template.loader import get_template
from django.core.mail import EmailMultiAlternatives
from django.conf import settings

template = get_template("correo.html")
content = template.render(context)

email = EmailMultialternatives(
	"asunto_correo",
	"texto_plano_alternativo_del_correo",
	settings.EMAIL_HOST_USER,
	["destinatario1@gmail.com","destinatario2@gmail.com"],
)

email.attach_alternative(content, "text/html")

email.send()

####################################  FIXTURES  ###################################################################

Este comando guarda información de una base de datos para exportar:

python manage.py dumpdata nombre_app > nombre_app.json

Para cargarlo en otro proyecto (poniendo el databasedump.json en la carpeta del manage.py)

python manage.py loaddata nombre_app.json


https://riptutorial.com/django/example/17482/fixtures

###################################  SERVICIO REST  ##############################################################

Creamos una app llamada nombre_app donde residirá el API:

pip install django restframework

En INSTALLED_APPS añadimos la linea

'rest-framework'

En la carpeta de la nombre_app crear el archivo serializer.py:

from rest_framework import serializers
from . import models

class Nombre_appSerializer(serializers.ModelSerializer):
	class Meta:
		model = models.nombre_clase
		fileds = "__all__"  --> Podemos optar por indicar una lista [] varios campos del modelo

Luego creamos el archivo viewsets.py :

from rest_framework import viewsets
from . import models
from . import serializer

class Nombre_appViewSet(viewsets.ModelViewSet):
	queryset = models._Nombre_clase.objects.all()  --> Generar el tipo de queryset que haga falta con la BBDD
	serializerClass = serializer.Nombre_appSerializer

En el archivo urls.py:

from rest_framework import routers
from . import viewsets

router = routers.SimpleRouter()
router.register("nombre_app", Nombre_appViewSet)

urlpatterns = router.urls

En el achivo urls.py de la carpeta principal del proyecto, incluir las rutas nuestra nueva app:

from django.urls import include

urlpatterns = [
	path("api/v1.0/", include("nombre_app.urls")
]

Con esto podemos probar el API de la siguiente manera :

http://www.dominio.com/api/v1.0/nombre_app , esto presentará la información en formato JSON


############################### EXCEPCION DOESNOTEXIST  ######################################################

Podemos gestionar las excepciones de Django para mostrar al usuario lo que consideremos conveniente

En este caso manejamos la excepción DoesNotExist que muestra Django si en la URL espera un parámetro (id) y este no existe

from django.http import Http404

from django.shortcuts import render, get_object_or_404

from . import models

def dynamic_lookup_view(request, id):

	try:
	    obj = models.Nombre_clase.objects.get(pk = id)	 
   
	except models.Nombre_clase.DoesNotExist:
	    raise Http404

	context = {"object":obj}

	return render (request, "mi_pagina.html", context)


##################################  DJANGO REST FRAMEWORK  ##################################################

pip install djangorestframework

En settings.py

INSTALLED_APPS = (
    ...
    'rest_framework',
)

También podemos declarar en los settings de django el diccionario REST_FRAMEWORK donde podremos añadir optativamente
múltiples opciones de configuración de Django Rest Framework (DRF)

REST_FRAMEWORK = {
}

DRF se basa fundamentalmente en 3 componentes: los serializadores, las vistas y los routers

Los routers son una herramienta que nos permiten definir las urls de nuestro API (url que servirá la información del API)

Las views no son más que extensiones de las class-view de django

Los serializadores nos permiten definir al detalle cómo serán las respuestas que devolverá nuestro API y cómo procesaremos 
el contenido de las peticiones que nos lleguen.


Ej
En este caso definimos un serializador asociado al modelo User de django que modeliza los usuarios de la aplicación. De todos los 
posibles campos del modelo user le decimos a nuestro serializador que sólo use el nombre de usuario y el correo electrónico.

#serializers.py

from django.contrib.auth.models import User
from rest_framework import serializers

OPCION 1 usando la clase Serializer

class UserSerializer(serializers.Serializer):
	#aqui definimos los mismos campos que en el model
	user = serializers.CharField(max_length = 50)
	email = serializers.EmailField()
	etc...

	def create(self, validated_data): ------------------> método para añadir objetos en el Model
		return User.objects.create(validated_data)	

	def update(self, instance, validated_data): ------------------> método para hacer updates en el Model
		instance.user = validated_data.get("user", instance.user)	
		instance.email = validated_data.get("email", instance.email)	
		etc...
		instance.save()
		return instance

Aqui debemos tener en cuenta las pautas que sigue la serialización,  ejemplo usando el shell de Django:

#Abrimos el shell de Django

python manage.py shell

from . import models
from . import serializers
from rest_framework.renderers import JSONRenderer
from rest_framework.parsers import JSONParser

#Creamos un objeto en el Model

usuario = models.User("user" = mi_usuario, email = "mail@gamil.com")
usuario.save()

#Creamos el serializador

serializer = serializers.UserSerializer(usuario)

#Esta propiedad contiene el diccionario de python creado por el serializador

serializer.data -->  {"user":"mi_usuario", "mail":"mail@gmail.com"}

#Y este otro muestra el JSON

content = JSONRenderer().render(serializer.data)

Podemos seralizar directamente un queryset del Model

serializer = serializers.UserSerializer(User.objects.all(), many = True) --> El segundo argumento es necesario para
									     serializar más de un objeto

#Y ahora creamos la vista basada en una función en el views.py:

from django.http import HttpResponse, JsonResponse
from rest_framework.parsers import JSONParser
from . import models
from . import serializers
from django.views.decorators.csrf import csrf_exempt  --> Esto es para añadir el decorador @csrf_exempt , que a 
						          efectos de hacer pruebas, anula la necesidad de tener
							  un csrf_token al hacer un POST

@csrf_exempt
def user_list(request):
	if request.method == "GET":
		usuarios = models.User.objects.all()
		serializer = serializers.UserSerializer(usuarios, many = True)
		return = JsonResponse(serializer.data, safe = False) --> El segundo argumento va en False para que
									 los datos puedan ser cualquier objeto
									 serializable en JSON, si va en True, sólo
									 admite diccionarios
									 
	elif request.method == "POST":
		data = JSONParser().parse(request)
		serializer = serializers.UserSerializer(data = data)
		if serializer.is_valid():
			serializer.save()
			return JsonResponse(serializer.data, status = 201) --> status de creación OK
		else:
			return JsonResponse(serializer.errors, status = 400) --> Los datos de la petición no son válidos

#Y finalmente añadimos el API al urls.py

urls.py del proyecto

from django urls import path, include

urlpatterns = [path("", include("mi_api_app.urls")]

urls.py del app que contiene el API

from . import views

urlpatterns = [path("usuarios", views.user_list)]

Existe una herramienta llamada POSTMAN que permite hacer pruebas de peticiones GET y POST con archivos JSON hacia
nuestro Model

#Si necesitamos que la vista recupere el detalle de un objeto en concreto:

@csrf_exempt
def user_detail(request, id):
	try:
		usuario = models.User.objects.get(pk = id)
	except models.User DoesNotExist:
		return HttpResponse(status = 404)

	if request.method == "GET":
		serializer = serializers.UserSerializer(usuario)
		return JsonResponse(serializer.data, safe = False)
	if request.method == "POST":
		data = JSONParser().parse(request)
		serializer = serializers.UserSerializer(data = data)
		if serializer.is_valid():
			serializer.save()
			return JsonResponse(serializer.data, status = 201) --> status de creación OK
		else:
			return JsonResponse(serializer.errors, status = 400) --> Los datos de la petición no son válidos

#Y en la ruta

urlpatterns = [path("user-detail/<int:id>", views.user_detail)]



OPCION 2 usando la clase ModelSerializer (RECOMENDADA)

class UserSerializer(serializers.ModelSerializer):
    class Meta:
        model = models.User
        fields = ('username', 'email') --> todos, o sólo los que queramos


Y ahora creamos la vista heredando de la clase ModelViewSet , que recupera y renderiza la información del serializador

#views.py

from django.contrib.auth.models import User
from rest_framework import viewsets
from . import serializers

class UserViewSet(viewsets.ModelViewSet):
    """
    API endpoint that allows users to be viewed or edited.
    """
    queryset = User.objects.all().order_by('-date_joined')
    serializer_class = serializers.UserSerializer


Y por último definimos la URL donde se expondrá nuestro API

#urls.py


from django.conf.urls import path, include
from rest_framework import routers
from . import views

router = routers.DefaultRouter()

router.register(r'users', views.UserViewSet)

urlpatterns = [
    path("", include(router.urls))
]

Las configuraciones adicionales (tamaño de página, excepciones, formato de fecha y hora, paginazión...) se realizan en el
diccionario REST_FRAMEWORK del settings.py .  Ver https://www.django-rest-framework.org/tutorial/quickstart/

Ej paginación

REST_FRAMEWORK = {
    'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.PageNumberPagination',
    'PAGE_SIZE': 10
}
	

Para testear el API, existe la libreria httpie , que es muy sencilla de usar:

pip install httpie

Y luego para usarla en el python shell 

http http://127.0.0.1:8000/mi_api

O directamente podemos cargar la URL en un navegador


------------------------------------- API VIEW DECORATOR -------------------------------------

from rest_framework.decorators imoprt api_view
from rest_framework.response import Response
from rest_framework import status
from . import serializers
from . impor models

El decorador @api_view() recibe los argumentos GET y POST y nos ayuda a reducir un poco todo lo
codificado anteriormente, según esté diseñada la vista, tambien podria recibir los métodos PUT y
DELETE


@api_view(["GET", "POST"])
def user_list(request):
	if request.method == "GET":
		usuarios = models.User.objects.all()
		serializer = serializers.UserSerializer(usuarios, many = True)
		return Response(serializer.data)  --> Usamos Response en lugar de JSONResponse

	elif request.method == "POST":
		serializer = serializers.UserSerializer(data = request.data) --> No necesitamos el JSONParser
		if serializer.is_valid():
			serializer.save()
			return Response(serializer.data, status = status.HTTP_201_CREATED)
		else:
			return Response(serializer.errors, status = status.HTTP_400_BAD_REQUEST)


Como vemos , con este decorador ahorramos un poco de código


--------------------------------  CLASS BASED API VIEWS  --------------------------------------------

Podemos crear vistas basadas en clases en lugar de funciones

from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import status
from . import serializers
from . impor models

class UserAPIView(APIView):
	def get(self, request):
		usuarios = models.User.objects.all()
		serializer = serializers.UserSerializer(usuarios, many = True)
		return Response(serializer.data)

	def post(self, request):
		serializer = serializers.UserSerializer(data = request.data)
		if serializer.is_valid():
			serializer.save()
			return Response(serializer.data, status = status.HTTP_201_CREATED)
		else:
			return Response(serializer.errors, status = status.HTTP_400_BAD_REQUEST)

Para trabajar con un objeto en concreto, habría que añadir el id a los argumentos de ambos métodos,
modificar el queryset y suprimir el many = True
	
En el urls.py

from django.urls import path
from . import views

urlpatterns = [path("listado-usuarios", views.UserAPIView.as_view()]


Heredando de APIView hemos reducido aún mas las lineas de código necesarias para crear la vista del API


-----------------------------  GENERIC VIEWS & MIXINS  -------------------------------------------------

from rest_framework import generic
from rest_framework import mixins
from . import serializers
from . import models

class GenericAPIView(generics.GenericAPIView, 
		     mixins.ListModelMixin, 
		     mixins.CreateModelMixin, 
                     mixins.UpdateModelMixin,
		     mixins.RetrieveModelMixin,
		     mixins.DestroyModelMixin):

	serializer_class = serializers.UserSerializer
	queryset = models.User.objects.all() --> si trabajamos con un id, models.User.objects.get(pk = id)
	lookup_field = "id"

	def get(self, request, id):
		if id:
		    return self.Retrieve(request) --> Propiedad de RetrieveModelMixin
		else:
		    return self.list(request) --> Propiedad de la clase ListModelMixin

	def post(self, request):
		return self.create(request) --> Propiedad de la clase CreateModelMixin

	def put(self, request, id):
		return self.update(request, id) --> Propiedad de la clase UpdateModelMixin

	def delete(self, request, id)
		return self.destroy(request, id)  --> Propiedad de la clase DestroyModelMixin


-----------------------------------  AUTENTICACION  ------------------------------------------------------


Tipos de autenticación:

Basic Authentication - recomendada sólo para propósitos de testing

Session Authentication - recomendada para clientes AJAX , usa el sello de sesión de Django

Token Authentication - La más recomendada en escenarios de producción

Es necesario añadir en el settings.py el escenario de autenticación que se va a utilizar:

REST_FRAMEWORK = {
    'DEFAULT_AUTHENTICATION_CLASSES': [
        'rest_framework.authentication.BasicAuthentication',
        'rest_framework.authentication.SessionAuthentication',	
    ]
}
	
También se puede añadir directamente en las vistas basadas en la clase APIView (ver API GUIDE- authentication
en la documentación oficial). Ej de autenticación básica y de sesión

from rest_framework.authentication import SessionAuthentication, BasicAuthentication
from rest_framewok.permissions import IsAuthenticated

class GenericAPIView(generics.GenericAPIView, 
		     mixins.ListModelMixin, 
		     mixins.CreateModelMixin, 
                     mixins.UpdateModelMixin,
		     mixins.RetrieveModelMixin,
		     mixins.DestroyModelMixin):

	serializer_class = serializers.UserSerializer
	queryset = models.User.objects.all()
	lookup_field = "id"
	authentication_classes = [SessionAuthentication, BasicAuthentication]--> añadimos las clases de autenticación,
										 el framework buscará el modo de autenticación
										 según el orden en la lista
	permission_classes = [IsAuthenticated]

	def get(self, request, id):
		if id:
		    return self.Retrieve(request)
		else:
		    return self.list(request)

	def post(self, request):
		return self.create(request)

	def put(self, request, id):
		return self.update(request, id)

	def delete(self, request, id)
		return self.destroy(request, id)

Con estos modelos de autenticación, si el usuario ya está logado en la sesión Django , tendrá acceso, y si no lo está,
podrá acceder simplemente facilitando un usuario y contraseña

Ej usando la autenticación mediante Token (RECOMENDADA)

INSTALLED_APPS = [
	'rest_framework.authtoken'
]

python manage.py migrate --> necesario para añadir la nueva clase de autenticación al modelo

Una vez hecho esto, debemos ir al panel de administración para crear un token para cada usuario que vaya a tener
acceso al API

En el views.py

from rest_framework.authentication import TokenAuthentication
from rest_framewok.permissions import IsAuthenticated

class GenericAPIView(generics.GenericAPIView, 
		     mixins.ListModelMixin, 
		     mixins.CreateModelMixin, 
                     mixins.UpdateModelMixin,
		     mixins.RetrieveModelMixin,
		     mixins.DestroyModelMixin):

	serializer_class = serializers.UserSerializer
	queryset = models.User.objects.all()
	lookup_field = "id"
	authentication_classes = [TokenAuthentication]
	permission_classes = [IsAuthenticated]

	def get(self, request, id):
		if id:
		    return self.Retrieve(request)
		else:
		    return self.list(request)

	def post(self, request):
		return self.create(request)

	def put(self, request, id):
		return self.update(request, id)

	def delete(self, request, id)
		return self.destroy(request, id)

En este caso el usuario debe enviar el token definido junto con su solicitud (aqui ya no es necesario usuario
y password)

-------------------------------------  VIEWSETS & ROUTERS  --------------------------------------------------

Usando la clase Viewset

En el views.py

from rest_framework impor viewsets
from rest_framework.response import Response
from django.shortcuts impor get_object_or_404
from . import models
from . import serializers

class UserViewset(viewsets.Viewset):

	def list(self, request):
		usuarios = models.User.objects.all()
		serializer = serializers.UserSerializer(usuarios, many = True)
		return Response(serializer.data)

	def create(self, request):
		serializer = serializers.UserSerializer(data = request.data)
		if serializer.is_valid():
			serializer.save()
			return Response(serializer.data, status = status.HTTP_201_CREATED)
		else:
			return Response(serializer.errors, status = status.HTTP_400_BAD_REQUEST)
	
	def retrieve(self, request, pk = None):
		queryset = models.Usuario.objects.all()
		usuario = get_object_or_404(queryset, pk = pk)
		serializer = serializers.UserSerializer(usuarios, many = True)
		return Response(serializer.data)

	def update(self, request, pk = None):
		queryset = models.Usuario.objects.get(pk = pk)
		usuario = get_object_or_404(queryset)
		serializer = serializers.UserSerializer(usuario, data = request.data)
		if serializer.is_valid():
			serializer.save()
			return Response(serializer.data)
		else:
			return Response(serializer.errors, status = status.HTTP_400_BAD_REQUEST)
	
En el urls.py

from . import views
from rest_framework.routers import DefaultRouter
from django.urls import path, include

router = DefaultRouter()

router.register = ("usuarios", UserViewset, basename = "gestion-usuarios")

urlpatterns = [
	path("", include(router.urls),
	path(""/<int:pk>, include(router.urls)
]

En los argumentos de router.register tenemos "usuarios" , que es el prefijo URL que vamos a usar, y luego
al UserViewset le ponemos el basename "gestion-usuarios" , lo cual dejará nuestra URL de esta manera

.../usuarios/gestion-usuarios

Si no definimos un basename,  el framework le asignará prefijo_url-nombre_viewset


----------------------------------  GENERIC VIEWSETS  ----------------------------------------------------

from rest_framework import viewsets
from rest_framework import mixins

class UserViewSet(viewsets.genericViewSet,
		  mixins.ListModelMixin, 
		  mixins.CreateModelMixin, 
                  mixins.UpdateModelMixin,
		  mixins.RetrieveModelMixin,
		  mixins.DestroyModelMixin):

	serializer_class = serializers.UserSerializer
	queryset = models.User.objects.all()

En este caso ya no hace falta añadir nada más para usar los métodos de los mixins debido al código que traemos
al heredar de genericViewSet

--------------------------------  MODEL VIEWSETS  ----------------------------------------------------------

from rest_framework import viewsets
from . import serializers
from . import models

Esta clase ya trae incluidas las acciones disponibles en los mixins , con lo cual ya no necesitamos heredar
de ellos


class UserViewSet(viewsets.ModelViewSet):
	serializer_class = serializers.UserSerializer
	quertset = models.User.objects.all()
	
Con esto nuestra API ya puede realizar todas las acciones CRUD



##################################  DJANGO CMS (CONTENT MANAGEMENT SYSTEM)  ########################################

Django CMS es un gestor de contenido Open Source , creamos en PyCharm un nuevo entorno virtual y lo activamos, le instalamos 
al env la versión de Python que nos interese y luego instalamos dentro de dicho entorno Django CMS:

pip install djangocms-installer

Una vez instalado , podemos indicarle la creación de un nuevo proyecto y de una carpeta para este

djangocms -p nombre_proyecto nombre_carpeta

El sistema crea el administrador admin / admin

Para acceder , añadimos a la URL de nuestra página /?edit , entonces nos pedirá el usuario y contraseña del CMS en la
parte superior de la página, si añadimos /admin, accedemos al panel de administracion de Django

Elementos del toolbar :

nombre_del_site --> (en local example.com) Panel de administración, arbol de páginas del site y su organización y otros elementos de administración,
		    los links a mostrar dependerán de los permisos del usuario
		    En el arbol del site, la página principal aparece con el icono de una casa, y si alguna página tiene
		    subpáginas (esto se ve en el path de la URL , ej  pagina/subpagina) aparece un icono de mostrar/ocultar
		    en el desplegable las subpaginas hijas. Simplemene haciendo drag & drop podemos convertir una subpágina
		    en hija de una página distinta
		    El check Menu indica si la página está incluida o no en la navegación pública
		    La opción EN (o ES si el lenguaje es español) indica si la página tiene versión publica sin borrador (verde) , 
		    versión publica + borrador (azul) o sólo borrador (gris). Si el site tiene versión en más de un idioma, habrá 
		    una columna con estos datos por cada uno, los circulos de colores son clickables para publicar o despublicar
		    una página
		    La opción View nos muestra la página
		    El icono del engranaje permite modificar el título , el slug, los metadatos...
		    Las Acciones permiten copiar, pegar y borrar la página , el simbolo + permite añadir una subpágina hija
		    (que luego se puede cambiar de sitio haciendo drag & drop)
		    En info podemos ver la fecha de modificación, usuario de la modificación, etc...
		    En el filtro existe la opción de programar la fecha de publicación y de expiración de una página

Page --> Muestra los elementos de la web que estamos administrando actualmente, se puede por ejemplo ocultar
	 temporalmente un elemento usando Hide in navigation y haciendo doble click sobre el elemento en cuestión,
	 para volver a mostrarlo pulsamos Display in navigation

History --> log de cambios en el site

Language --> Para cambiar de idioma

Create --> botón para crear contenido ( nueva página, nueva subpágina, nuevo elemento ) , en la creación de nueva página
	   si no ponemos nada en el slug, este se creará automáticamente

Content --> Abre la web en modo edición, haciendo doble click sobre cualquier elemento, podemos modificarlo

Publish changes --> Botón que publica las modificaciones

View published --> Vista para ver la versión pública (lo que ven los usuarios), no se modifica mientras no
		   se pulse el botón Publish changes

Structure --> Estructura del site , aqui aparecerán los placehoders que hayamos incluidos en los templates. Dichos placeholders
	      nos permiten agregar contenidos y plug ins, como por ejemplo djangocms-bootstrap4 (nos permirá crear los contenedores,
	      las filas y las columnas con sus correspondientes clases), el de Google Maps , agregar etiquetas HTML,  estilos...
	      Ver http://docs.django-cms.org/en/latest/topics/commonly_used_plugins.html

Plantilla base para proyectos Django CMS:

Por defecto se usará la primera de CMS_TEMPLATES en settings.py

CMS_TEMPLATES = (
    ## Customize this
    ('fullwidth.html', 'Fullwidth'),
    ('sidebar_left.html', 'Sidebar Left'),
    ('sidebar_right.html', 'Sidebar Right')
)

Que será de serie fullwidth.html , pero podemos añadir la que queramos

PLACEHOLDERS

Son una manera sencilla de reservar espacio en la web para nuestros contenidos

{% placeholder "content" %} --> Podemos añadir el nombre que queramos al placeholder


Este es el esqueleto mínimo de un template en Django CMS

{% load cms_tags menu_tags sekizai_tags %} --> Librerias de Django CMS necesarias
<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{% page_attribute "page_title" %}</title>
    {% render_block "css" %}
</head>
<body>
    {% cms_toolbar %}
    {% block content %}
    {% placeholder "content" %}
    {% endblock content %}
    {% render_block "js" %}
</body>
</html>

Dispondremos de una plantilla base.htnl de la cual heredarán el resto de templates, añadiendo
siempre {% load cms_tags %},  ejemplo:

{% extends "base.html" %}
{% load cms_tags %}

{% block title %}{% page_attribute "page_title" %}{% endblock title %}

{% block content %}
{% placeholder "feature" %}
{% placeholder "content" %}
{% placeholder "splashbox" %}
{% endblock content %}

Existe la posibilidad de usar static placeholders que mostrarán el mismo contenido en todas las páginas
del site ( por ej un mismo footer), en el Structure de Django CMS aparecerán con el icono de una chincheta

{% static_placeholder 'footer' %}

MENÚS

Para renderizar el menú CMS la plantilla debe contener primero {% load menu_tags %} para cargar la librería 
necesaria para usar show_menu , y luego usar por ejemplo una expresión similar a esta:

<ul class="nav navbar-nav">
    {% show_menu 0 100 100 100 "menu.html" %}
</ul>

La carga de menu_tags y otras librerias necesarias se hace siempre al principio del template:

{% load cms_tags menu_tags sekizai_tags %}

